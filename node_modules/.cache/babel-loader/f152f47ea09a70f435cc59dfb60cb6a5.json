{"ast":null,"code":"import { ethers, BigNumber } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20ABI } from \"../abi/IERC20.json\";\nimport { abi as OlympusStakingABI } from \"../abi/OlympusStakingv2.json\";\nimport { abi as ClaimABI } from \"../abi/Claim.json\";\nimport { abi as StakingHelperABI } from \"../abi/StakingHelper.json\";\nimport { clearPendingTxn, fetchPendingTxns, getStakingTypeText } from \"./PendingTxnsSlice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./AccountSlice\";\nimport { error, info } from \"../slices/MessagesSlice\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\n\nfunction alreadyApprovedToken(token, stakeAllowance, unstakeAllowance, aguruAllowance) {\n  // set defaults\n  let bigZero = BigNumber.from(\"0\");\n  let applicableAllowance = bigZero; // determine which allowance to check\n\n  if (token === \"ohm\") {\n    applicableAllowance = stakeAllowance;\n  } else if (token === \"sohm\") {\n    applicableAllowance = unstakeAllowance;\n  } else if (token === \"aguru\") {\n    applicableAllowance = aguruAllowance;\n  } // check if allowance exists\n\n\n  if (applicableAllowance.gt(bigZero)) return true;\n  return false;\n}\n\nexport const changeApproval = createAsyncThunk(\"stake/changeApproval\", async ({\n  token,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const ohmContract = new ethers.Contract(addresses[networkID].OX_ADDRESS, ierc20ABI, signer);\n  const sohmContract = new ethers.Contract(addresses[networkID].SOX_ADDRESS, ierc20ABI, signer);\n  const aguruContract = new ethers.Contract(addresses[networkID].AOX_ADDRESS, ierc20ABI, signer);\n  let approveTx;\n  let stakeAllowance = await ohmContract.allowance(address, addresses[networkID].STAKING_HELPER_ADDRESS);\n  let unstakeAllowance = await sohmContract.allowance(address, addresses[networkID].STAKING_ADDRESS);\n  let aguruAllowance = await aguruContract.allowance(address, addresses[networkID].CLAIM_ADDRESS); // return early if approval has already happened\n\n  if (alreadyApprovedToken(token, stakeAllowance, unstakeAllowance, aguruAllowance)) {\n    dispatch(info(\"Approval completed.\"));\n    return dispatch(fetchAccountSuccess({\n      staking: {\n        ohmStake: +stakeAllowance,\n        ohmUnstake: +unstakeAllowance\n      },\n      claim: {\n        aguruAllowance\n      }\n    }));\n  }\n\n  try {\n    if (token === \"ohm\") {\n      // won't run if stakeAllowance > 0\n      approveTx = await ohmContract.approve(addresses[networkID].STAKING_HELPER_ADDRESS, ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString());\n    } else if (token === \"sohm\") {\n      approveTx = await sohmContract.approve(addresses[networkID].STAKING_ADDRESS, ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString());\n    } else if (token === \"aguru\") {\n      approveTx = await aguruContract.approve(addresses[networkID].CLAIM_ADDRESS, ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString());\n    }\n\n    let text = \"Approve \";\n\n    if (token === \"ohm\") {\n      text += \"Staking\";\n    } else if (token === \"sohm\") {\n      text += \"Unstaking\";\n    } else if (token === \"aguru\") {\n      text += \"Claiming\";\n    }\n\n    let pendingTxnType;\n\n    if (token === \"ohm\") {\n      pendingTxnType = \"approve_staking\";\n    } else if (token === \"sohm\") {\n      pendingTxnType = \"approve_unstaking\";\n    } else {\n      pendingTxnType = \"approve_claiming\";\n    }\n\n    if (approveTx) {\n      dispatch(fetchPendingTxns({\n        txnHash: approveTx.hash,\n        text,\n        type: pendingTxnType\n      }));\n      await approveTx.wait();\n    }\n  } catch (e) {\n    dispatch(error(e.message));\n    return;\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  } // go get fresh allowances\n\n\n  stakeAllowance = await ohmContract.allowance(address, addresses[networkID].STAKING_HELPER_ADDRESS);\n  unstakeAllowance = await sohmContract.allowance(address, addresses[networkID].STAKING_ADDRESS);\n  aguruAllowance = await aguruContract.allowance(address, addresses[networkID].CLAIM_ADDRESS);\n  return dispatch(fetchAccountSuccess({\n    staking: {\n      ohmStake: +stakeAllowance,\n      ohmUnstake: +unstakeAllowance\n    },\n    claim: {\n      aguruAllowance\n    }\n  }));\n});\nexport const changeStake = createAsyncThunk(\"stake/changeStake\", async ({\n  action,\n  value,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const staking = new ethers.Contract(addresses[networkID].STAKING_ADDRESS, OlympusStakingABI, signer);\n  const stakingHelper = new ethers.Contract(addresses[networkID].STAKING_HELPER_ADDRESS, StakingHelperABI, signer);\n  let stakeTx;\n  let uaData = {\n    address: address,\n    value: value,\n    approved: true,\n    txHash: null,\n    type: null\n  };\n\n  try {\n    if (action === \"stake\") {\n      uaData.type = \"stake\";\n      stakeTx = await stakingHelper.stake(ethers.utils.parseUnits(value, \"gwei\"));\n    } else {\n      uaData.type = \"unstake\";\n      stakeTx = await staking.unstake(ethers.utils.parseUnits(value, \"gwei\"), true);\n    }\n\n    const pendingTxnType = action === \"stake\" ? \"staking\" : \"unstaking\";\n    uaData.txHash = stakeTx.hash;\n    dispatch(fetchPendingTxns({\n      txnHash: stakeTx.hash,\n      text: getStakingTypeText(action),\n      type: pendingTxnType\n    }));\n    await stakeTx.wait();\n  } catch (e) {\n    uaData.approved = false;\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else {\n      dispatch(error(rpcError.message));\n    }\n\n    return;\n  } finally {\n    if (stakeTx) {\n      segmentUA(uaData);\n      dispatch(clearPendingTxn(stakeTx.hash));\n    }\n  }\n\n  dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n});\nexport const exchangeAOX = createAsyncThunk(\"stake/exchangeAOX\", async ({\n  aguruBalance,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const claimContract = new ethers.Contract(addresses[networkID].CLAIM_ADDRESS, ClaimABI, signer);\n  let claimTx;\n  let uaData = {\n    address: address,\n    value: \"0\",\n    approved: true,\n    txHash: null,\n    type: null\n  };\n\n  try {\n    uaData.type = \"claiming\";\n    claimTx = await claimContract.migrate(ethers.utils.parseUnits(aguruBalance, \"gwei\"));\n    uaData.txHash = claimTx.hash;\n    dispatch(fetchPendingTxns({\n      txnHash: claimTx.hash,\n      text: \"Exchanging aOX for OX\",\n      type: \"claiming\"\n    }));\n    await claimTx.wait();\n  } catch (e) {\n    uaData.approved = false;\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to exchange more than your aOX balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else {\n      dispatch(error(rpcError.message));\n    }\n\n    return;\n  } finally {\n    if (claimTx) {\n      segmentUA(uaData);\n      dispatch(clearPendingTxn(claimTx.hash));\n    }\n  }\n\n  dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n});","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/StakeThunk.ts"],"names":["ethers","BigNumber","addresses","abi","ierc20ABI","OlympusStakingABI","ClaimABI","StakingHelperABI","clearPendingTxn","fetchPendingTxns","getStakingTypeText","createAsyncThunk","fetchAccountSuccess","getBalances","error","info","segmentUA","alreadyApprovedToken","token","stakeAllowance","unstakeAllowance","aguruAllowance","bigZero","from","applicableAllowance","gt","changeApproval","provider","address","networkID","dispatch","signer","getSigner","ohmContract","Contract","OX_ADDRESS","sohmContract","SOX_ADDRESS","aguruContract","AOX_ADDRESS","approveTx","allowance","STAKING_HELPER_ADDRESS","STAKING_ADDRESS","CLAIM_ADDRESS","staking","ohmStake","ohmUnstake","claim","approve","utils","parseUnits","toString","text","pendingTxnType","txnHash","hash","type","wait","e","message","changeStake","action","value","stakingHelper","stakeTx","uaData","approved","txHash","stake","unstake","rpcError","code","indexOf","exchangeAOX","aguruBalance","claimContract","claimTx","migrate"],"mappings":"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","sourcesContent":["import { ethers, BigNumber } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20ABI } from \"../abi/IERC20.json\";\nimport { abi as OlympusStakingABI } from \"../abi/OlympusStakingv2.json\";\nimport { abi as ClaimABI } from \"../abi/Claim.json\";\nimport { abi as StakingHelperABI } from \"../abi/StakingHelper.json\";\nimport { clearPendingTxn, fetchPendingTxns, getStakingTypeText } from \"./PendingTxnsSlice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./AccountSlice\";\nimport { error, info } from \"../slices/MessagesSlice\";\nimport { IActionValueAsyncThunk, IChangeApprovalAsyncThunk, IJsonRPCError } from \"./interfaces\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\nimport { IERC20, OlympusStakingv2, StakingHelper } from \"src/typechain\";\n\ninterface IUAData {\n  address: string;\n  value: string;\n  approved: boolean;\n  txHash: string | null;\n  type: string | null;\n}\n\nfunction alreadyApprovedToken(\n  token: string,\n  stakeAllowance: BigNumber,\n  unstakeAllowance: BigNumber,\n  aguruAllowance: BigNumber,\n) {\n  // set defaults\n  let bigZero = BigNumber.from(\"0\");\n  let applicableAllowance = bigZero;\n\n  // determine which allowance to check\n  if (token === \"ohm\") {\n    applicableAllowance = stakeAllowance;\n  } else if (token === \"sohm\") {\n    applicableAllowance = unstakeAllowance;\n  } else if (token === \"aguru\") {\n    applicableAllowance = aguruAllowance;\n  }\n\n  // check if allowance exists\n  if (applicableAllowance.gt(bigZero)) return true;\n\n  return false;\n}\n\nexport const changeApproval = createAsyncThunk(\n  \"stake/changeApproval\",\n  async ({ token, provider, address, networkID }: IChangeApprovalAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const ohmContract = new ethers.Contract(addresses[networkID].OX_ADDRESS as string, ierc20ABI, signer) as IERC20;\n    const sohmContract = new ethers.Contract(addresses[networkID].SOX_ADDRESS as string, ierc20ABI, signer) as IERC20;\n    const aguruContract = new ethers.Contract(addresses[networkID].AOX_ADDRESS as string, ierc20ABI, signer) as IERC20;\n    let approveTx;\n    let stakeAllowance = await ohmContract.allowance(address, addresses[networkID].STAKING_HELPER_ADDRESS);\n    let unstakeAllowance = await sohmContract.allowance(address, addresses[networkID].STAKING_ADDRESS);\n    let aguruAllowance = await aguruContract.allowance(address, addresses[networkID].CLAIM_ADDRESS);\n\n    // return early if approval has already happened\n    if (alreadyApprovedToken(token, stakeAllowance, unstakeAllowance, aguruAllowance)) {\n      dispatch(info(\"Approval completed.\"));\n      return dispatch(\n        fetchAccountSuccess({\n          staking: {\n            ohmStake: +stakeAllowance,\n            ohmUnstake: +unstakeAllowance,\n          },\n          claim: {\n            aguruAllowance,\n          },\n        }),\n      );\n    }\n\n    try {\n      if (token === \"ohm\") {\n        // won't run if stakeAllowance > 0\n        approveTx = await ohmContract.approve(\n          addresses[networkID].STAKING_HELPER_ADDRESS,\n          ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString(),\n        );\n      } else if (token === \"sohm\") {\n        approveTx = await sohmContract.approve(\n          addresses[networkID].STAKING_ADDRESS,\n          ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString(),\n        );\n      } else if (token === \"aguru\") {\n        approveTx = await aguruContract.approve(\n          addresses[networkID].CLAIM_ADDRESS,\n          ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString(),\n        );\n      }\n\n      let text = \"Approve \";\n\n      if (token === \"ohm\") {\n        text += \"Staking\";\n      } else if (token === \"sohm\") {\n        text += \"Unstaking\";\n      } else if (token === \"aguru\") {\n        text += \"Claiming\";\n      }\n\n      let pendingTxnType;\n\n      if (token === \"ohm\") {\n        pendingTxnType = \"approve_staking\";\n      } else if (token === \"sohm\") {\n        pendingTxnType = \"approve_unstaking\";\n      } else {\n        pendingTxnType = \"approve_claiming\";\n      }\n\n      if (approveTx) {\n        dispatch(fetchPendingTxns({ txnHash: approveTx.hash, text, type: pendingTxnType }));\n\n        await approveTx.wait();\n      }\n    } catch (e: unknown) {\n      dispatch(error((e as IJsonRPCError).message));\n      return;\n    } finally {\n      if (approveTx) {\n        dispatch(clearPendingTxn(approveTx.hash));\n      }\n    }\n\n    // go get fresh allowances\n    stakeAllowance = await ohmContract.allowance(address, addresses[networkID].STAKING_HELPER_ADDRESS);\n    unstakeAllowance = await sohmContract.allowance(address, addresses[networkID].STAKING_ADDRESS);\n    aguruAllowance = await aguruContract.allowance(address, addresses[networkID].CLAIM_ADDRESS);\n\n    return dispatch(\n      fetchAccountSuccess({\n        staking: {\n          ohmStake: +stakeAllowance,\n          ohmUnstake: +unstakeAllowance,\n        },\n        claim: {\n          aguruAllowance,\n        },\n      }),\n    );\n  },\n);\n\nexport const changeStake = createAsyncThunk(\n  \"stake/changeStake\",\n  async ({ action, value, provider, address, networkID }: IActionValueAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const staking = new ethers.Contract(\n      addresses[networkID].STAKING_ADDRESS as string,\n      OlympusStakingABI,\n      signer,\n    ) as OlympusStakingv2;\n    const stakingHelper = new ethers.Contract(\n      addresses[networkID].STAKING_HELPER_ADDRESS as string,\n      StakingHelperABI,\n      signer,\n    ) as StakingHelper;\n\n    let stakeTx;\n    let uaData: IUAData = {\n      address: address,\n      value: value,\n      approved: true,\n      txHash: null,\n      type: null,\n    };\n    try {\n      if (action === \"stake\") {\n        uaData.type = \"stake\";\n        stakeTx = await stakingHelper.stake(ethers.utils.parseUnits(value, \"gwei\"));\n      } else {\n        uaData.type = \"unstake\";\n        stakeTx = await staking.unstake(ethers.utils.parseUnits(value, \"gwei\"), true);\n      }\n      const pendingTxnType = action === \"stake\" ? \"staking\" : \"unstaking\";\n      uaData.txHash = stakeTx.hash;\n      dispatch(fetchPendingTxns({ txnHash: stakeTx.hash, text: getStakingTypeText(action), type: pendingTxnType }));\n      await stakeTx.wait();\n    } catch (e: unknown) {\n      uaData.approved = false;\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"),\n        );\n      } else {\n        dispatch(error(rpcError.message));\n      }\n      return;\n    } finally {\n      if (stakeTx) {\n        segmentUA(uaData);\n\n        dispatch(clearPendingTxn(stakeTx.hash));\n      }\n    }\n    dispatch(getBalances({ address, networkID, provider }));\n  },\n);\n\nexport const exchangeAOX = createAsyncThunk(\n  \"stake/exchangeAOX\",\n  async ({ aguruBalance, provider, address, networkID }: any, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const claimContract = new ethers.Contract(addresses[networkID].CLAIM_ADDRESS as string, ClaimABI, signer);\n\n    let claimTx;\n    let uaData: IUAData = {\n      address: address,\n      value: \"0\",\n      approved: true,\n      txHash: null,\n      type: null,\n    };\n    try {\n      uaData.type = \"claiming\";\n      claimTx = await claimContract.migrate(ethers.utils.parseUnits(aguruBalance, \"gwei\"));\n      uaData.txHash = claimTx.hash;\n      dispatch(fetchPendingTxns({ txnHash: claimTx.hash, text: \"Exchanging aOX for OX\", type: \"claiming\" }));\n      await claimTx.wait();\n    } catch (e: unknown) {\n      uaData.approved = false;\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\n            \"You may be trying to exchange more than your aOX balance! Error code: 32603. Message: ds-math-sub-underflow\",\n          ),\n        );\n      } else {\n        dispatch(error(rpcError.message));\n      }\n      return;\n    } finally {\n      if (claimTx) {\n        segmentUA(uaData);\n\n        dispatch(clearPendingTxn(claimTx.hash));\n      }\n    }\n    dispatch(getBalances({ address, networkID, provider }));\n  },\n);\n"]},"metadata":{},"sourceType":"module"}