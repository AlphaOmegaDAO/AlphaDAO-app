{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as OlympusStakingv2ABI } from \"../abi/OlympusStakingv2.json\";\nimport { abi as sOHMv2 } from \"../abi/sOhmv2.json\";\nimport { abi as GuruABI } from \"../abi/Guru.json\";\nimport { setAll, getTokenPrice, getMarketPrice } from \"../helpers\";\nimport allBonds from \"../helpers/AllBonds\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nconst initialState = {\n  loading: false,\n  loadingMarketPrice: false\n};\nexport const loadAppDetails = createAsyncThunk(\"app/loadAppDetails\", async ({\n  networkID,\n  provider\n}, {\n  dispatch\n}) => {\n  // NOTE (appleseed): marketPrice from Graph was delayed, so get CoinGecko price\n  // const marketPrice = parseFloat(graphData.data.protocolMetrics[0].ohmPrice);\n  let marketPrice;\n\n  try {\n    const originalPromiseResult = await dispatch(loadMarketPrice({\n      networkID: networkID,\n      provider: provider\n    })).unwrap();\n    marketPrice = originalPromiseResult === null || originalPromiseResult === void 0 ? void 0 : originalPromiseResult.marketPrice;\n  } catch (rejectedValueOrSerializedError) {\n    // handle error here\n    console.error(\"Returned a null response from dispatch(loadMarketPrice)\");\n    return;\n  }\n\n  const currentBlock = await provider.getBlockNumber();\n  const stakingContract = new ethers.Contract(addresses[networkID].STAKING_ADDRESS, OlympusStakingv2ABI, provider);\n  const sohmMainContract = new ethers.Contract(addresses[networkID].SOX_ADDRESS, sOHMv2, provider);\n  const guruMainContract = new ethers.Contract(addresses[networkID].OX_ADDRESS, GuruABI, provider); // Calculating staking\n\n  const epoch = await stakingContract.epoch();\n  console.log(`epoch`, epoch);\n  const stakingReward = epoch.distribute;\n  const ts = await sohmMainContract.totalSupply();\n  console.log(`ts`, ts);\n  const totalSupply = (await guruMainContract.totalSupply()) / Math.pow(10, 9);\n  const marketCap = totalSupply * marketPrice;\n  const circ = await sohmMainContract.circulatingSupply();\n  const circAny = circ;\n  const circSupply = circAny / Math.pow(10, 9);\n  const stakingTVL = circSupply * marketPrice;\n  console.log(`circ`, circ);\n  const stakingRebase = Number(stakingReward.toString()) / Number(circ.toString());\n  console.log(\"stakingRebase\", stakingRebase);\n  const fiveDayRate = Math.pow(1 + stakingRebase, 5 * 3) - 1;\n  const stakingAPY = Math.pow(1 + stakingRebase, 365 * 3) - 1;\n  console.log(`stakingAPY ${stakingAPY}`);\n  const tokenAmountsPromises = allBonds.map(bond => bond.getTreasuryBalance(networkID, provider));\n  const tokenAmounts = await Promise.all(tokenAmountsPromises);\n  console.log(\"tokenAmounts\", tokenAmounts);\n  const treasuryMarketValue = tokenAmounts.reduce((curr, prev) => {\n    return curr + prev;\n  }, 0); // Current index\n\n  const currentIndex = await stakingContract.index();\n  return {\n    currentIndex: ethers.utils.formatUnits(currentIndex, \"gwei\"),\n    currentBlock,\n    fiveDayRate,\n    stakingAPY,\n    stakingTVL,\n    stakingRebase,\n    marketCap,\n    marketPrice,\n    circSupply,\n    totalSupply,\n    treasuryMarketValue\n  };\n});\n/**\n * checks if app.slice has marketPrice already\n * if yes then simply load that state\n * if no then fetches via `loadMarketPrice`\n *\n * `usage`:\n * ```\n * const originalPromiseResult = await dispatch(\n *    findOrLoadMarketPrice({ networkID: networkID, provider: provider }),\n *  ).unwrap();\n * originalPromiseResult?.whateverValue;\n * ```\n */\n\nexport const findOrLoadMarketPrice = createAsyncThunk(\"app/findOrLoadMarketPrice\", async ({\n  networkID,\n  provider\n}, {\n  dispatch,\n  getState\n}) => {\n  const state = getState();\n  let marketPrice; // check if we already have loaded market price\n\n  if (state.app.loadingMarketPrice === false && state.app.marketPrice) {\n    // go get marketPrice from app.state\n    marketPrice = state.app.marketPrice;\n  } else {\n    // we don't have marketPrice in app.state, so go get it\n    try {\n      const originalPromiseResult = await dispatch(loadMarketPrice({\n        networkID: networkID,\n        provider: provider\n      })).unwrap();\n      marketPrice = originalPromiseResult === null || originalPromiseResult === void 0 ? void 0 : originalPromiseResult.marketPrice;\n    } catch (rejectedValueOrSerializedError) {\n      // handle error here\n      console.error(\"Returned a null response from dispatch(loadMarketPrice)\");\n      return;\n    }\n  }\n\n  return {\n    marketPrice\n  };\n});\n/**\n * - fetches the OHM price from CoinGecko (via getTokenPrice)\n * - falls back to fetch marketPrice from ohm-dai contract\n * - updates the App.slice when it runs\n */\n\nconst loadMarketPrice = createAsyncThunk(\"app/loadMarketPrice\", async ({\n  networkID,\n  provider\n}) => {\n  let marketPrice;\n\n  try {\n    marketPrice = await getMarketPrice({\n      networkID,\n      provider\n    });\n    marketPrice = marketPrice / Math.pow(10, 9);\n  } catch (e) {\n    console.log(`e`);\n    console.log(e);\n    marketPrice = await getTokenPrice(\"guru\");\n  }\n\n  return {\n    marketPrice\n  };\n});\nconst appSlice = createSlice({\n  name: \"app\",\n  initialState,\n  reducers: {\n    fetchAppSuccess(state, action) {\n      setAll(state, action.payload);\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(loadAppDetails.pending, state => {\n      state.loading = true;\n    }).addCase(loadAppDetails.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(loadAppDetails.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.error(error.name, error.message, error.stack);\n    }).addCase(loadMarketPrice.pending, (state, action) => {\n      state.loadingMarketPrice = true;\n    }).addCase(loadMarketPrice.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loadingMarketPrice = false;\n    }).addCase(loadMarketPrice.rejected, (state, {\n      error\n    }) => {\n      state.loadingMarketPrice = false;\n      console.error(error.name, error.message, error.stack);\n    });\n  }\n});\n\nconst baseInfo = state => state.app;\n\nexport default appSlice.reducer;\nexport const {\n  fetchAppSuccess\n} = appSlice.actions;\nexport const getAppState = createSelector(baseInfo, app => app);","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/AppSlice.ts"],"names":["ethers","addresses","abi","OlympusStakingv2ABI","sOHMv2","GuruABI","setAll","getTokenPrice","getMarketPrice","allBonds","createSlice","createSelector","createAsyncThunk","initialState","loading","loadingMarketPrice","loadAppDetails","networkID","provider","dispatch","marketPrice","originalPromiseResult","loadMarketPrice","unwrap","rejectedValueOrSerializedError","console","error","currentBlock","getBlockNumber","stakingContract","Contract","STAKING_ADDRESS","sohmMainContract","SOX_ADDRESS","guruMainContract","OX_ADDRESS","epoch","log","stakingReward","distribute","ts","totalSupply","Math","pow","marketCap","circ","circulatingSupply","circAny","circSupply","stakingTVL","stakingRebase","Number","toString","fiveDayRate","stakingAPY","tokenAmountsPromises","map","bond","getTreasuryBalance","tokenAmounts","Promise","all","treasuryMarketValue","reduce","curr","prev","currentIndex","index","utils","formatUnits","findOrLoadMarketPrice","getState","state","app","e","appSlice","name","reducers","fetchAppSuccess","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","message","stack","baseInfo","reducer","actions","getAppState"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as OlympusStakingv2ABI } from \"../abi/OlympusStakingv2.json\";\nimport { abi as sOHMv2 } from \"../abi/sOhmv2.json\";\nimport { abi as GuruABI } from \"../abi/Guru.json\";\nimport { setAll, getTokenPrice, getMarketPrice } from \"../helpers\";\nimport allBonds from \"../helpers/AllBonds\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { RootState } from \"src/store\";\nimport { IBaseAsyncThunk } from \"./interfaces\";\nimport { OlympusStakingv2, SOhmv2 } from \"../typechain\";\n\nconst initialState = {\n  loading: false,\n  loadingMarketPrice: false,\n};\n\nexport const loadAppDetails = createAsyncThunk(\n  \"app/loadAppDetails\",\n  async ({ networkID, provider }: IBaseAsyncThunk, { dispatch }) => {\n    // NOTE (appleseed): marketPrice from Graph was delayed, so get CoinGecko price\n    // const marketPrice = parseFloat(graphData.data.protocolMetrics[0].ohmPrice);\n    let marketPrice;\n    try {\n      const originalPromiseResult = await dispatch(\n        loadMarketPrice({ networkID: networkID, provider: provider }),\n      ).unwrap();\n      marketPrice = originalPromiseResult?.marketPrice;\n    } catch (rejectedValueOrSerializedError) {\n      // handle error here\n      console.error(\"Returned a null response from dispatch(loadMarketPrice)\");\n      return;\n    }\n\n    const currentBlock = await provider.getBlockNumber();\n\n    const stakingContract = new ethers.Contract(\n      addresses[networkID].STAKING_ADDRESS as string,\n      OlympusStakingv2ABI,\n      provider,\n    ) as OlympusStakingv2;\n\n    const sohmMainContract = new ethers.Contract(\n      addresses[networkID].SOX_ADDRESS as string,\n      sOHMv2,\n      provider,\n    ) as SOhmv2;\n\n    const guruMainContract = new ethers.Contract(addresses[networkID].OX_ADDRESS as string, GuruABI, provider);\n\n    // Calculating staking\n    const epoch = await stakingContract.epoch();\n    console.log(`epoch`, epoch);\n    const stakingReward = epoch.distribute;\n    const ts = await sohmMainContract.totalSupply();\n    console.log(`ts`, ts);\n    const totalSupply = (await guruMainContract.totalSupply()) / Math.pow(10, 9);\n    const marketCap = totalSupply * marketPrice;\n    const circ = await sohmMainContract.circulatingSupply();\n    const circAny = circ as any;\n    const circSupply = circAny / Math.pow(10, 9);\n    const stakingTVL = circSupply * marketPrice;\n    console.log(`circ`, circ);\n    const stakingRebase = Number(stakingReward.toString()) / Number(circ.toString());\n    console.log(\"stakingRebase\", stakingRebase);\n    const fiveDayRate = Math.pow(1 + stakingRebase, 5 * 3) - 1;\n    const stakingAPY = Math.pow(1 + stakingRebase, 365 * 3) - 1;\n    console.log(`stakingAPY ${stakingAPY}`);\n\n    const tokenAmountsPromises = allBonds.map(bond => bond.getTreasuryBalance(networkID, provider));\n    const tokenAmounts = await Promise.all(tokenAmountsPromises);\n    console.log(\"tokenAmounts\", tokenAmounts);\n    const treasuryMarketValue = tokenAmounts.reduce((curr, prev) => {\n      return curr + prev;\n    }, 0);\n\n    // Current index\n    const currentIndex = await stakingContract.index();\n\n    return {\n      currentIndex: ethers.utils.formatUnits(currentIndex, \"gwei\"),\n      currentBlock,\n      fiveDayRate,\n      stakingAPY,\n      stakingTVL,\n      stakingRebase,\n      marketCap,\n      marketPrice,\n      circSupply,\n      totalSupply,\n      treasuryMarketValue,\n    } as IAppData;\n  },\n);\n\n/**\n * checks if app.slice has marketPrice already\n * if yes then simply load that state\n * if no then fetches via `loadMarketPrice`\n *\n * `usage`:\n * ```\n * const originalPromiseResult = await dispatch(\n *    findOrLoadMarketPrice({ networkID: networkID, provider: provider }),\n *  ).unwrap();\n * originalPromiseResult?.whateverValue;\n * ```\n */\nexport const findOrLoadMarketPrice = createAsyncThunk(\n  \"app/findOrLoadMarketPrice\",\n  async ({ networkID, provider }: IBaseAsyncThunk, { dispatch, getState }) => {\n    const state: any = getState();\n    let marketPrice;\n    // check if we already have loaded market price\n    if (state.app.loadingMarketPrice === false && state.app.marketPrice) {\n      // go get marketPrice from app.state\n      marketPrice = state.app.marketPrice;\n    } else {\n      // we don't have marketPrice in app.state, so go get it\n      try {\n        const originalPromiseResult = await dispatch(\n          loadMarketPrice({ networkID: networkID, provider: provider }),\n        ).unwrap();\n        marketPrice = originalPromiseResult?.marketPrice;\n      } catch (rejectedValueOrSerializedError) {\n        // handle error here\n        console.error(\"Returned a null response from dispatch(loadMarketPrice)\");\n        return;\n      }\n    }\n    return { marketPrice };\n  },\n);\n\n/**\n * - fetches the OHM price from CoinGecko (via getTokenPrice)\n * - falls back to fetch marketPrice from ohm-dai contract\n * - updates the App.slice when it runs\n */\nconst loadMarketPrice = createAsyncThunk(\"app/loadMarketPrice\", async ({ networkID, provider }: IBaseAsyncThunk) => {\n  let marketPrice: number;\n  try {\n    marketPrice = await getMarketPrice({ networkID, provider });\n    marketPrice = marketPrice / Math.pow(10, 9);\n  } catch (e) {\n    console.log(`e`);\n    console.log(e);\n    marketPrice = await getTokenPrice(\"guru\");\n  }\n  return { marketPrice };\n});\n\ninterface IAppData {\n  readonly circSupply: number;\n  readonly currentIndex?: string;\n  readonly currentBlock?: number;\n  readonly fiveDayRate?: number;\n  readonly marketCap: number;\n  readonly marketPrice: number;\n  readonly stakingAPY?: number;\n  readonly stakingRebase?: number;\n  readonly stakingTVL: number;\n  readonly totalSupply: number;\n  readonly treasuryBalance?: number;\n  readonly treasuryMarketValue?: number;\n}\n\nconst appSlice = createSlice({\n  name: \"app\",\n  initialState,\n  reducers: {\n    fetchAppSuccess(state, action) {\n      setAll(state, action.payload);\n    },\n  },\n  extraReducers: builder => {\n    builder\n      .addCase(loadAppDetails.pending, state => {\n        state.loading = true;\n      })\n      .addCase(loadAppDetails.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(loadAppDetails.rejected, (state, { error }) => {\n        state.loading = false;\n        console.error(error.name, error.message, error.stack);\n      })\n      .addCase(loadMarketPrice.pending, (state, action) => {\n        state.loadingMarketPrice = true;\n      })\n      .addCase(loadMarketPrice.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loadingMarketPrice = false;\n      })\n      .addCase(loadMarketPrice.rejected, (state, { error }) => {\n        state.loadingMarketPrice = false;\n        console.error(error.name, error.message, error.stack);\n      });\n  },\n});\n\nconst baseInfo = (state: RootState) => state.app;\n\nexport default appSlice.reducer;\n\nexport const { fetchAppSuccess } = appSlice.actions;\n\nexport const getAppState = createSelector(baseInfo, app => app);\n"]},"metadata":{},"sourceType":"module"}