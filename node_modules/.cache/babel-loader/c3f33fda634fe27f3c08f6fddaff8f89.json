{"ast":null,"code":"import { ethers, BigNumber } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20Abi } from \"../abi/IERC20.json\";\nimport { abi as PrizePool } from \"../abi/33-together/PrizePoolAbi2.json\";\nimport { abi as AwardPool } from \"../abi/33-together/AwardAbi2.json\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { clearPendingTxn, fetchPendingTxns } from \"./PendingTxnsSlice\";\nimport { fetchAccountSuccess, getBalances } from \"./AccountSlice\";\nimport { getCreditMaturationDaysAndLimitPercentage } from \"../helpers/33Together\";\nimport { setAll } from \"../helpers\";\nimport { error, info } from \"./MessagesSlice\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\nexport const getPoolValues = createAsyncThunk(\"pool/getPoolValues\", async ({\n  networkID,\n  provider\n}) => {\n  // calculate 33-together\n  const poolReader = new ethers.Contract(addresses[networkID].PT_PRIZE_POOL_ADDRESS, PrizePool, provider);\n  const poolAwardBalance = await poolReader.callStatic.captureAwardBalance();\n  const creditPlanOf = await poolReader.creditPlanOf(addresses[networkID].PT_TOKEN_ADDRESS);\n  const poolCredit = getCreditMaturationDaysAndLimitPercentage(creditPlanOf.creditRateMantissa, creditPlanOf.creditLimitMantissa);\n  const awardReader = new ethers.Contract(addresses[networkID].PT_PRIZE_STRATEGY_ADDRESS, AwardPool, provider);\n  const poolAwardPeriodRemainingSeconds = await awardReader.prizePeriodRemainingSeconds();\n  return {\n    awardBalance: ethers.utils.formatUnits(poolAwardBalance, \"gwei\"),\n    awardPeriodRemainingSeconds: poolAwardPeriodRemainingSeconds.toString(),\n    creditMaturationInDays: poolCredit[0],\n    creditLimitPercentage: poolCredit[1]\n  };\n});\nexport const getRNGStatus = createAsyncThunk(\"pool/getRNGStatus\", async ({\n  networkID,\n  provider\n}) => {\n  const awardReader = new ethers.Contract(addresses[networkID].PT_PRIZE_STRATEGY_ADDRESS, AwardPool, provider);\n  const isRngRequested = await awardReader.isRngRequested();\n  let isRngTimedOut = false;\n  if (isRngRequested) isRngTimedOut = await awardReader.isRngTimedOut();\n  return {\n    isRngRequested: isRngRequested,\n    isRngTimedOut: isRngTimedOut,\n    rngRequestCompleted: Date.now()\n  };\n});\nexport const changeApproval = createAsyncThunk(\"pool/changeApproval\", async ({\n  token,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const sohmContract = new ethers.Contract(addresses[networkID].SOHM_ADDRESS, ierc20Abi, signer);\n  let approveTx;\n  let depositAllowance = await sohmContract.allowance(address, addresses[networkID].PT_PRIZE_POOL_ADDRESS); // return early if approval already exists\n\n  if (depositAllowance.gt(BigNumber.from(\"0\"))) {\n    dispatch(info(\"Approval completed.\"));\n    return dispatch(fetchAccountSuccess({\n      pooling: {\n        sohmPool: +depositAllowance\n      }\n    }));\n  }\n\n  try {\n    if (token === \"sohm\") {\n      approveTx = await sohmContract.approve(addresses[networkID].PT_PRIZE_POOL_ADDRESS, ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString());\n      const text = \"Approve Pool Deposit\";\n      const pendingTxnType = \"approve_pool_together\";\n      dispatch(fetchPendingTxns({\n        txnHash: approveTx.hash,\n        text,\n        type: pendingTxnType\n      }));\n      await approveTx.wait();\n    }\n  } catch (e) {\n    dispatch(error(e.message));\n    return;\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  } // go get fresh allowance\n\n\n  depositAllowance = await sohmContract.allowance(address, addresses[networkID].PT_PRIZE_POOL_ADDRESS);\n  return dispatch(fetchAccountSuccess({\n    pooling: {\n      sohmPool: +depositAllowance\n    }\n  }));\n}); // NOTE (appleseed): https://docs.pooltogether.com/protocol/prize-pool#depositing\n\nexport const poolDeposit = createAsyncThunk(\"pool/deposit\", async ({\n  action,\n  value,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const poolContract = new ethers.Contract(addresses[networkID].PT_PRIZE_POOL_ADDRESS, PrizePool, signer);\n  let poolTx;\n  let uaData = {\n    address: address,\n    value: value,\n    type: \"33t Deposit\",\n    approved: false,\n    txHash: \"\"\n  };\n\n  try {\n    if (action === \"deposit\") {\n      poolTx = await poolContract.depositTo(address, ethers.utils.parseUnits(value, \"gwei\"), addresses[networkID].PT_TOKEN_ADDRESS, \"0x0000000000000000000000000000000000000000\" // referral address\n      );\n      const text = \"Pool \" + action;\n      const pendingTxnType = \"pool_deposit\";\n      dispatch(fetchPendingTxns({\n        txnHash: poolTx.hash,\n        text: text,\n        type: pendingTxnType\n      }));\n      await poolTx.wait();\n    } else {\n      console.log(\"unrecognized action: \", action);\n    }\n  } catch (e) {\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else {\n      dispatch(error(rpcError.message));\n    }\n\n    return;\n  } finally {\n    if (poolTx) {\n      uaData.txHash = poolTx.hash;\n      uaData.approved = true;\n      segmentUA(uaData);\n      dispatch(clearPendingTxn(poolTx.hash));\n    }\n  }\n\n  dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n});\nexport const getEarlyExitFee = createAsyncThunk(\"pool/getEarlyExitFee\", async ({\n  value,\n  provider,\n  address,\n  networkID\n}) => {\n  const poolReader = new ethers.Contract(addresses[networkID].PT_PRIZE_POOL_ADDRESS, PrizePool, provider); // NOTE (appleseed): we chain callStatic in the below function to force the transaction through w/o a gas fee\n  // ... this may be a result of `calculateEarlyExitFee` not being explicity declared as `view` or `pure` in the contract.\n  // Explanation from ethers docs: https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic\n  //\n  // `callStatic` would be equivalent to `call` in web3js: https://web3js.readthedocs.io/en/v1.2.11/web3-eth-contract.html#methods-mymethod-call\n  //\n  // PoolTogether actually uses a custom implementation of a MultiCall using web3js to batch two calls together:\n  // https://github.com/pooltogether/etherplex/blob/9cf1b94e8879c08c7951d1308c14712aaaa5cec7/src/MulticallContract.ts#L33\n  //\n\n  const earlyExitFee = await poolReader.callStatic.calculateEarlyExitFee(address, addresses[networkID].PT_TOKEN_ADDRESS, ethers.utils.parseUnits(value, \"gwei\")); // NOTE (appleseed): poolTogether calcs this credit, but it's not used...\n\n  const credit = await poolReader.callStatic.balanceOfCredit(address, addresses[networkID].PT_TOKEN_ADDRESS);\n  return {\n    withdraw: {\n      earlyExitFee: earlyExitFee,\n      stringExitFee: ethers.utils.formatUnits(earlyExitFee.exitFee, \"gwei\"),\n      credit: credit\n    }\n  };\n}); // NOTE (appleseed): https://docs.pooltogether.com/protocol/prize-pool#withdraw-instantly\n\nexport const poolWithdraw = createAsyncThunk(\"pool/withdraw\", async ({\n  action,\n  value,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const poolContract = new ethers.Contract(addresses[networkID].PT_PRIZE_POOL_ADDRESS, PrizePool, signer);\n  let poolTx;\n  let uaData = {\n    address: address,\n    value: value,\n    type: \"Withdraw\",\n    earlyExitFee: \"\",\n    approved: false,\n    txHash: \"\"\n  };\n\n  try {\n    if (action === \"withdraw\") {\n      const earlyExitFee = await dispatch(getEarlyExitFee({\n        value,\n        provider,\n        address,\n        networkID\n      }));\n      poolTx = await poolContract.withdrawInstantlyFrom(address, ethers.utils.parseUnits(value, \"gwei\"), addresses[networkID].PT_TOKEN_ADDRESS, earlyExitFee.payload.withdraw.earlyExitFee.exitFee // maximum exit fee\n      // TS-REFACTOR-TODO: set the payload type above once we've added typechain in.\n      );\n      uaData.earlyExitFee = earlyExitFee.payload.withdraw.stringExitFee;\n      uaData.txHash = poolTx.hash;\n      const text = \"Pool \" + action;\n      const pendingTxnType = \"pool_withdraw\";\n      dispatch(fetchPendingTxns({\n        txnHash: poolTx.hash,\n        text: text,\n        type: pendingTxnType\n      }));\n      await poolTx.wait();\n    } else {\n      console.log(\"unrecognized action: \", action);\n    }\n  } catch (e) {\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else {\n      dispatch(error(rpcError.message));\n    }\n\n    return;\n  } finally {\n    if (poolTx) {\n      dispatch(clearPendingTxn(poolTx.hash));\n    }\n  }\n\n  uaData.approved = true;\n  segmentUA(uaData);\n  dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n});\nexport const awardProcess = createAsyncThunk(\"pool/awardProcess\", async ({\n  action,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const poolContract = new ethers.Contract(addresses[networkID].PT_PRIZE_STRATEGY_ADDRESS, AwardPool, signer);\n  let poolTx;\n\n  try {\n    var _poolTx;\n\n    if (action === \"startAward\") {\n      poolTx = await poolContract.startAward();\n    } else if (action === \"completeAward\") {\n      poolTx = await poolContract.completeAward();\n    } else if (action === \"cancelAward\") {\n      poolTx = await poolContract.cancelAward();\n    } else {\n      console.log(\"unrecognized action: \", action);\n    }\n\n    const text = \"Pool \" + action;\n    const pendingTxnType = \"pool_\" + action;\n    const txnHash = poolTx ? poolTx.hash : \"\";\n    dispatch(fetchPendingTxns({\n      txnHash,\n      text: text,\n      type: pendingTxnType\n    }));\n    await ((_poolTx = poolTx) === null || _poolTx === void 0 ? void 0 : _poolTx.wait());\n  } catch (e) {\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else {\n      dispatch(error(rpcError.message));\n    }\n\n    return;\n  } finally {\n    if (poolTx) {\n      dispatch(clearPendingTxn(poolTx.hash));\n    }\n  }\n\n  dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n});\nconst initialState = {\n  loading: false\n};\nconst poolTogetherSlice = createSlice({\n  name: \"poolData\",\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(getPoolValues.pending, state => {\n      state.loading = true;\n    }).addCase(getPoolValues.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(getPoolValues.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.log(error);\n    }).addCase(getRNGStatus.pending, state => {\n      state.loading = true;\n    }).addCase(getRNGStatus.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(getRNGStatus.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\nexport default poolTogetherSlice.reducer;\n\nconst baseInfo = state => state.poolData;\n\nexport const getPoolState = createSelector(baseInfo, app => app);","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/PoolThunk.ts"],"names":["ethers","BigNumber","addresses","abi","ierc20Abi","PrizePool","AwardPool","createAsyncThunk","createSelector","createSlice","clearPendingTxn","fetchPendingTxns","fetchAccountSuccess","getBalances","getCreditMaturationDaysAndLimitPercentage","setAll","error","info","segmentUA","getPoolValues","networkID","provider","poolReader","Contract","PT_PRIZE_POOL_ADDRESS","poolAwardBalance","callStatic","captureAwardBalance","creditPlanOf","PT_TOKEN_ADDRESS","poolCredit","creditRateMantissa","creditLimitMantissa","awardReader","PT_PRIZE_STRATEGY_ADDRESS","poolAwardPeriodRemainingSeconds","prizePeriodRemainingSeconds","awardBalance","utils","formatUnits","awardPeriodRemainingSeconds","toString","creditMaturationInDays","creditLimitPercentage","getRNGStatus","isRngRequested","isRngTimedOut","rngRequestCompleted","Date","now","changeApproval","token","address","dispatch","signer","getSigner","sohmContract","SOHM_ADDRESS","approveTx","depositAllowance","allowance","gt","from","pooling","sohmPool","approve","parseUnits","text","pendingTxnType","txnHash","hash","type","wait","e","message","poolDeposit","action","value","poolContract","poolTx","uaData","approved","txHash","depositTo","console","log","rpcError","code","indexOf","getEarlyExitFee","earlyExitFee","calculateEarlyExitFee","credit","balanceOfCredit","withdraw","stringExitFee","exitFee","poolWithdraw","withdrawInstantlyFrom","payload","awardProcess","startAward","completeAward","cancelAward","initialState","loading","poolTogetherSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","rejected","reducer","baseInfo","poolData","getPoolState","app"],"mappings":"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","sourcesContent":["import { ethers, BigNumber } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20Abi } from \"../abi/IERC20.json\";\nimport { abi as PrizePool } from \"../abi/33-together/PrizePoolAbi2.json\";\nimport { abi as AwardPool } from \"../abi/33-together/AwardAbi2.json\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { clearPendingTxn, fetchPendingTxns } from \"./PendingTxnsSlice\";\nimport { fetchAccountSuccess, getBalances } from \"./AccountSlice\";\nimport { getCreditMaturationDaysAndLimitPercentage } from \"../helpers/33Together\";\nimport { setAll } from \"../helpers\";\nimport { error, info } from \"./MessagesSlice\";\nimport { RootState } from \"src/store\";\nimport {\n  IValueAsyncThunk,\n  IBaseAsyncThunk,\n  IChangeApprovalAsyncThunk,\n  IActionValueAsyncThunk,\n  IActionAsyncThunk,\n  IJsonRPCError,\n} from \"./interfaces\";\nimport { AwardAbi2, PrizePoolAbi, PrizePoolAbi2, SOHM } from \"src/typechain\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\n\nexport const getPoolValues = createAsyncThunk(\n  \"pool/getPoolValues\",\n  async ({ networkID, provider }: IBaseAsyncThunk) => {\n    // calculate 33-together\n    const poolReader = new ethers.Contract(\n      addresses[networkID].PT_PRIZE_POOL_ADDRESS,\n      PrizePool,\n      provider,\n    ) as PrizePoolAbi;\n    const poolAwardBalance = await poolReader.callStatic.captureAwardBalance();\n    const creditPlanOf = await poolReader.creditPlanOf(addresses[networkID].PT_TOKEN_ADDRESS);\n    const poolCredit = getCreditMaturationDaysAndLimitPercentage(\n      creditPlanOf.creditRateMantissa,\n      creditPlanOf.creditLimitMantissa,\n    );\n\n    const awardReader = new ethers.Contract(\n      addresses[networkID].PT_PRIZE_STRATEGY_ADDRESS,\n      AwardPool,\n      provider,\n    ) as AwardAbi2;\n    const poolAwardPeriodRemainingSeconds = await awardReader.prizePeriodRemainingSeconds();\n\n    return {\n      awardBalance: ethers.utils.formatUnits(poolAwardBalance, \"gwei\"),\n      awardPeriodRemainingSeconds: poolAwardPeriodRemainingSeconds.toString(),\n      creditMaturationInDays: poolCredit[0],\n      creditLimitPercentage: poolCredit[1],\n    };\n  },\n);\n\nexport const getRNGStatus = createAsyncThunk(\"pool/getRNGStatus\", async ({ networkID, provider }: IBaseAsyncThunk) => {\n  const awardReader = new ethers.Contract(\n    addresses[networkID].PT_PRIZE_STRATEGY_ADDRESS,\n    AwardPool,\n    provider,\n  ) as AwardAbi2;\n  const isRngRequested = await awardReader.isRngRequested();\n  let isRngTimedOut = false;\n  if (isRngRequested) isRngTimedOut = await awardReader.isRngTimedOut();\n\n  return {\n    isRngRequested: isRngRequested,\n    isRngTimedOut: isRngTimedOut,\n    rngRequestCompleted: Date.now(),\n  };\n});\n\nexport const changeApproval = createAsyncThunk(\n  \"pool/changeApproval\",\n  async ({ token, provider, address, networkID }: IChangeApprovalAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const sohmContract = new ethers.Contract(addresses[networkID].SOHM_ADDRESS, ierc20Abi, signer) as SOHM;\n\n    let approveTx;\n    let depositAllowance = await sohmContract.allowance(address, addresses[networkID].PT_PRIZE_POOL_ADDRESS);\n\n    // return early if approval already exists\n    if (depositAllowance.gt(BigNumber.from(\"0\"))) {\n      dispatch(info(\"Approval completed.\"));\n      return dispatch(\n        fetchAccountSuccess({\n          pooling: {\n            sohmPool: +depositAllowance,\n          },\n        }),\n      );\n    }\n\n    try {\n      if (token === \"sohm\") {\n        approveTx = await sohmContract.approve(\n          addresses[networkID].PT_PRIZE_POOL_ADDRESS,\n          ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString(),\n        );\n\n        const text = \"Approve Pool Deposit\";\n        const pendingTxnType = \"approve_pool_together\";\n        dispatch(fetchPendingTxns({ txnHash: approveTx.hash, text, type: pendingTxnType }));\n        await approveTx.wait();\n      }\n    } catch (e: unknown) {\n      dispatch(error((e as IJsonRPCError).message));\n      return;\n    } finally {\n      if (approveTx) {\n        dispatch(clearPendingTxn(approveTx.hash));\n      }\n    }\n\n    // go get fresh allowance\n    depositAllowance = await sohmContract.allowance(address, addresses[networkID].PT_PRIZE_POOL_ADDRESS);\n\n    return dispatch(\n      fetchAccountSuccess({\n        pooling: {\n          sohmPool: +depositAllowance,\n        },\n      }),\n    );\n  },\n);\n\n// NOTE (appleseed): https://docs.pooltogether.com/protocol/prize-pool#depositing\nexport const poolDeposit = createAsyncThunk(\n  \"pool/deposit\",\n  async ({ action, value, provider, address, networkID }: IActionValueAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n    const signer = provider.getSigner();\n    const poolContract = new ethers.Contract(\n      addresses[networkID].PT_PRIZE_POOL_ADDRESS,\n      PrizePool,\n      signer,\n    ) as PrizePoolAbi;\n    let poolTx;\n    let uaData = {\n      address: address,\n      value: value,\n      type: \"33t Deposit\",\n      approved: false,\n      txHash: \"\",\n    };\n    try {\n      if (action === \"deposit\") {\n        poolTx = await poolContract.depositTo(\n          address,\n          ethers.utils.parseUnits(value, \"gwei\"),\n          addresses[networkID].PT_TOKEN_ADDRESS,\n          \"0x0000000000000000000000000000000000000000\", // referral address\n        );\n        const text = \"Pool \" + action;\n        const pendingTxnType = \"pool_deposit\";\n        dispatch(fetchPendingTxns({ txnHash: poolTx.hash, text: text, type: pendingTxnType }));\n        await poolTx.wait();\n      } else {\n        console.log(\"unrecognized action: \", action);\n      }\n    } catch (e: unknown) {\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"),\n        );\n      } else {\n        dispatch(error(rpcError.message));\n      }\n      return;\n    } finally {\n      if (poolTx) {\n        uaData.txHash = poolTx.hash;\n        uaData.approved = true;\n        segmentUA(uaData);\n        dispatch(clearPendingTxn(poolTx.hash));\n      }\n    }\n\n    dispatch(getBalances({ address, networkID, provider }));\n  },\n);\n\nexport const getEarlyExitFee = createAsyncThunk(\n  \"pool/getEarlyExitFee\",\n  async ({ value, provider, address, networkID }: IValueAsyncThunk) => {\n    const poolReader = new ethers.Contract(\n      addresses[networkID].PT_PRIZE_POOL_ADDRESS,\n      PrizePool,\n      provider,\n    ) as PrizePoolAbi;\n    // NOTE (appleseed): we chain callStatic in the below function to force the transaction through w/o a gas fee\n    // ... this may be a result of `calculateEarlyExitFee` not being explicity declared as `view` or `pure` in the contract.\n    // Explanation from ethers docs: https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic\n    //\n    // `callStatic` would be equivalent to `call` in web3js: https://web3js.readthedocs.io/en/v1.2.11/web3-eth-contract.html#methods-mymethod-call\n    //\n    // PoolTogether actually uses a custom implementation of a MultiCall using web3js to batch two calls together:\n    // https://github.com/pooltogether/etherplex/blob/9cf1b94e8879c08c7951d1308c14712aaaa5cec7/src/MulticallContract.ts#L33\n    //\n    const earlyExitFee = await poolReader.callStatic.calculateEarlyExitFee(\n      address,\n      addresses[networkID].PT_TOKEN_ADDRESS,\n      ethers.utils.parseUnits(value, \"gwei\"),\n    );\n    // NOTE (appleseed): poolTogether calcs this credit, but it's not used...\n    const credit = await poolReader.callStatic.balanceOfCredit(address, addresses[networkID].PT_TOKEN_ADDRESS);\n\n    return {\n      withdraw: {\n        earlyExitFee: earlyExitFee,\n        stringExitFee: ethers.utils.formatUnits(earlyExitFee.exitFee, \"gwei\"),\n        credit: credit,\n      },\n    };\n  },\n);\n\n// NOTE (appleseed): https://docs.pooltogether.com/protocol/prize-pool#withdraw-instantly\nexport const poolWithdraw = createAsyncThunk(\n  \"pool/withdraw\",\n  async ({ action, value, provider, address, networkID }: IActionValueAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const poolContract = new ethers.Contract(\n      addresses[networkID].PT_PRIZE_POOL_ADDRESS,\n      PrizePool,\n      signer,\n    ) as PrizePoolAbi2;\n\n    let poolTx;\n    let uaData = {\n      address: address,\n      value: value,\n      type: \"Withdraw\",\n      earlyExitFee: \"\",\n      approved: false,\n      txHash: \"\",\n    };\n    try {\n      if (action === \"withdraw\") {\n        const earlyExitFee = await dispatch(getEarlyExitFee({ value, provider, address, networkID }));\n        poolTx = await poolContract.withdrawInstantlyFrom(\n          address,\n          ethers.utils.parseUnits(value, \"gwei\"),\n          addresses[networkID].PT_TOKEN_ADDRESS,\n          (earlyExitFee.payload as any).withdraw.earlyExitFee.exitFee, // maximum exit fee\n          // TS-REFACTOR-TODO: set the payload type above once we've added typechain in.\n        );\n        uaData.earlyExitFee = (earlyExitFee.payload as any).withdraw.stringExitFee;\n        uaData.txHash = poolTx.hash;\n        const text = \"Pool \" + action;\n        const pendingTxnType = \"pool_withdraw\";\n        dispatch(fetchPendingTxns({ txnHash: poolTx.hash, text: text, type: pendingTxnType }));\n        await poolTx.wait();\n      } else {\n        console.log(\"unrecognized action: \", action);\n      }\n    } catch (e: unknown) {\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"),\n        );\n      } else {\n        dispatch(error(rpcError.message));\n      }\n      return;\n    } finally {\n      if (poolTx) {\n        dispatch(clearPendingTxn(poolTx.hash));\n      }\n    }\n    uaData.approved = true;\n    segmentUA(uaData);\n    dispatch(getBalances({ address, networkID, provider }));\n  },\n);\n\nexport const awardProcess = createAsyncThunk(\n  \"pool/awardProcess\",\n  async ({ action, provider, address, networkID }: IActionAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const poolContract = new ethers.Contract(\n      addresses[networkID].PT_PRIZE_STRATEGY_ADDRESS,\n      AwardPool,\n      signer,\n    ) as AwardAbi2;\n\n    let poolTx;\n\n    try {\n      if (action === \"startAward\") {\n        poolTx = await poolContract.startAward();\n      } else if (action === \"completeAward\") {\n        poolTx = await poolContract.completeAward();\n      } else if (action === \"cancelAward\") {\n        poolTx = await poolContract.cancelAward();\n      } else {\n        console.log(\"unrecognized action: \", action);\n      }\n      const text = \"Pool \" + action;\n      const pendingTxnType = \"pool_\" + action;\n      const txnHash: string = poolTx ? poolTx.hash : \"\";\n      dispatch(fetchPendingTxns({ txnHash, text: text, type: pendingTxnType }));\n      await poolTx?.wait();\n    } catch (e: unknown) {\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\"You may be trying to stake more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"),\n        );\n      } else {\n        dispatch(error(rpcError.message));\n      }\n      return;\n    } finally {\n      if (poolTx) {\n        dispatch(clearPendingTxn(poolTx.hash));\n      }\n    }\n\n    dispatch(getBalances({ address, networkID, provider }));\n  },\n);\n\nconst initialState = {\n  loading: false,\n};\n\nconst poolTogetherSlice = createSlice({\n  name: \"poolData\",\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder\n      .addCase(getPoolValues.pending, state => {\n        state.loading = true;\n      })\n      .addCase(getPoolValues.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(getPoolValues.rejected, (state, { error }) => {\n        state.loading = false;\n        console.log(error);\n      })\n      .addCase(getRNGStatus.pending, state => {\n        state.loading = true;\n      })\n      .addCase(getRNGStatus.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(getRNGStatus.rejected, (state, { error }) => {\n        state.loading = false;\n        console.log(error);\n      });\n  },\n});\n\nexport default poolTogetherSlice.reducer;\n\nconst baseInfo = (state: RootState) => state.poolData;\n\nexport const getPoolState = createSelector(baseInfo, app => app);\n"]},"metadata":{},"sourceType":"module"}