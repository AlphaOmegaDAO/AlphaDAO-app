{"ast":null,"code":"import { BigNumber, ethers } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20Abi } from \"../abi/IERC20.json\";\nimport { abi as sOHMv2 } from \"../abi/sOhmv2.json\";\nimport { abi as wsOHM } from \"../abi/wsOHM.json\";\nimport { setAll } from \"../helpers\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nexport const getBalances = createAsyncThunk(\"account/getBalances\", async ({\n  address,\n  networkID,\n  provider\n}) => {\n  let ohmBalance = BigNumber.from(0);\n  let sohmBalance = BigNumber.from(0);\n  let wsohmBalance = BigNumber.from(0);\n  let wsohmAsSohm = BigNumber.from(0);\n  let poolBalance = BigNumber.from(0);\n  let aguruBalance = BigNumber.from(0);\n\n  if (addresses[networkID].OX_ADDRESS) {\n    const ohmContract = new ethers.Contract(addresses[networkID].OX_ADDRESS, ierc20Abi, provider);\n    ohmBalance = await ohmContract.balanceOf(address);\n  }\n\n  if (addresses[networkID].SOX_ADDRESS) {\n    const sohmContract = new ethers.Contract(addresses[networkID].SOX_ADDRESS, ierc20Abi, provider);\n    sohmBalance = await sohmContract.balanceOf(address);\n  }\n\n  if (addresses[networkID].WSOX_ADDRESS) {\n    const wsohmContract = new ethers.Contract(addresses[networkID].WSOX_ADDRESS, wsOHM, provider);\n    wsohmBalance = await wsohmContract.balanceOf(address); // NOTE (appleseed): wsohmAsSohm is wsOHM given as a quantity of sOHM\n\n    wsohmAsSohm = await wsohmContract.wOHMTosOHM(wsohmBalance);\n  }\n\n  if (addresses[networkID].PT_TOKEN_ADDRESS) {\n    const poolTokenContract = new ethers.Contract(addresses[networkID].PT_TOKEN_ADDRESS, ierc20Abi, provider);\n    poolBalance = await poolTokenContract.balanceOf(address);\n  }\n\n  if (addresses[networkID].AOX_ADDRESS) {\n    const aguruContract = new ethers.Contract(addresses[networkID].AOX_ADDRESS, sOHMv2, provider);\n    aguruBalance = await aguruContract.balanceOf(address);\n  }\n\n  return {\n    balances: {\n      ohm: ethers.utils.formatUnits(ohmBalance, \"gwei\"),\n      sohm: ethers.utils.formatUnits(sohmBalance, \"gwei\"),\n      wsohm: ethers.utils.formatEther(wsohmBalance),\n      wsohmAsSohm: ethers.utils.formatUnits(wsohmAsSohm, \"gwei\"),\n      pool: ethers.utils.formatUnits(poolBalance, \"gwei\"),\n      aguru: ethers.utils.formatUnits(aguruBalance, \"gwei\")\n    }\n  };\n});\nexport const loadAccountDetails = createAsyncThunk(\"account/loadAccountDetails\", async ({\n  networkID,\n  provider,\n  address\n}) => {\n  let ohmBalance = BigNumber.from(0);\n  let sohmBalance = BigNumber.from(0);\n  let fsohmBalance = BigNumber.from(0);\n  let fsohmString = \"0.0\";\n  let wsohmBalance = BigNumber.from(0);\n  let wsohmAsSohm = BigNumber.from(0);\n  let wrapAllowance = BigNumber.from(0);\n  let unwrapAllowance = BigNumber.from(0);\n  let stakeAllowance = BigNumber.from(0);\n  let unstakeAllowance = BigNumber.from(0);\n  let aguruAllowance = BigNumber.from(0);\n  let aguruBalance = BigNumber.from(0);\n  let lpStaked = 0;\n  let pendingRewards = 0;\n  let lpBondAllowance = 0;\n  let daiBondAllowance = 0;\n  let aOHMAbleToClaim = 0;\n  let poolBalance = BigNumber.from(0);\n  let poolAllowance = BigNumber.from(0);\n  const daiContract = new ethers.Contract(addresses[networkID].DAI_ADDRESS, ierc20Abi, provider);\n  const daiBalance = await daiContract.balanceOf(address);\n\n  if (addresses[networkID].OX_ADDRESS) {\n    const ohmContract = new ethers.Contract(addresses[networkID].OX_ADDRESS, ierc20Abi, provider);\n    ohmBalance = await ohmContract.balanceOf(address);\n    stakeAllowance = await ohmContract.allowance(address, addresses[networkID].STAKING_HELPER_ADDRESS);\n  }\n\n  if (addresses[networkID].SOX_ADDRESS) {\n    const sohmContract = new ethers.Contract(addresses[networkID].SOX_ADDRESS, sOHMv2, provider);\n    sohmBalance = await sohmContract.balanceOf(address);\n    unstakeAllowance = await sohmContract.allowance(address, addresses[networkID].STAKING_ADDRESS); // poolAllowance = await sohmContract.allowance(address, addresses[networkID].PT_PRIZE_POOL_ADDRESS);\n    // wrapAllowance = await sohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n  }\n\n  if (addresses[networkID].AOX_ADDRESS) {\n    const aguruContract = new ethers.Contract(addresses[networkID].AOX_ADDRESS, sOHMv2, provider);\n    aguruBalance = await aguruContract.balanceOf(address);\n    aguruAllowance = await aguruContract.allowance(address, addresses[networkID].CLAIM_ADDRESS);\n  } // if (addresses[networkID].PT_TOKEN_ADDRESS) {\n  //   const poolTokenContract = new ethers.Contract(\n  //     addresses[networkID].PT_TOKEN_ADDRESS,\n  //     ierc20Abi,\n  //     provider,\n  //   ) as IERC20;\n  //   poolBalance = await poolTokenContract.balanceOf(address);\n  // }\n  // for (const fuseAddressKey of [\"FUSE_6_SOHM\", \"FUSE_18_SOHM\"]) {\n  //   if (addresses[networkID][fuseAddressKey]) {\n  //     const fsohmContract = new ethers.Contract(\n  //       addresses[networkID][fuseAddressKey] as string,\n  //       fuseProxy,\n  //       provider.getSigner(),\n  //     ) as FuseProxy;\n  //     // fsohmContract.signer;\n  //     const balanceOfUnderlying = await fsohmContract.callStatic.balanceOfUnderlying(address);\n  //     fsohmBalance = balanceOfUnderlying.add(fsohmBalance);\n  //   }\n  // }\n  // if (addresses[networkID].WSOX_ADDRESS) {\n  //   const wsohmContract = new ethers.Contract(\n  //     addresses[networkID].WSOX_ADDRESS as string,\n  //     wsOHM,\n  //     provider,\n  //   ) as WsOHM;\n  //   wsohmBalance = await wsohmContract.balanceOf(address);\n  //   // NOTE (appleseed): wsohmAsSohm is used to calc your next reward amount\n  //   wsohmAsSohm = await wsohmContract.wOHMTosOHM(wsohmBalance);\n  //   unwrapAllowance = await wsohmContract.allowance(address, addresses[networkID].WSOX_ADDRESS);\n  // }\n\n\n  return {\n    balances: {\n      dai: ethers.utils.formatEther(daiBalance),\n      ohm: ethers.utils.formatUnits(ohmBalance, \"gwei\"),\n      sohm: ethers.utils.formatUnits(sohmBalance, \"gwei\"),\n      fsohm: ethers.utils.formatUnits(fsohmBalance, \"gwei\"),\n      wsohm: ethers.utils.formatEther(wsohmBalance),\n      wsohmAsSohm: ethers.utils.formatUnits(wsohmAsSohm, \"gwei\"),\n      pool: ethers.utils.formatUnits(poolBalance, \"gwei\"),\n      aguru: ethers.utils.formatUnits(aguruBalance, \"gwei\")\n    },\n    staking: {\n      ohmStake: +stakeAllowance,\n      ohmUnstake: +unstakeAllowance\n    },\n    claim: {\n      aguruAllowance: aguruAllowance\n    },\n    wrapping: {\n      ohmWrap: +wrapAllowance,\n      ohmUnwrap: +unwrapAllowance\n    },\n    bonding: {\n      daiAllowance: daiBondAllowance\n    },\n    pooling: {\n      sohmPool: +poolAllowance\n    }\n  };\n});\nexport const calculateUserBondDetails = createAsyncThunk(\"account/calculateUserBondDetails\", async ({\n  address,\n  bond,\n  networkID,\n  provider\n}) => {\n  if (!address) {\n    return {\n      bond: \"\",\n      displayName: \"\",\n      bondIconSvg: \"\",\n      isLP: false,\n      allowance: 0,\n      balance: \"0\",\n      interestDue: 0,\n      bondMaturationBlock: 0,\n      pendingPayout: \"\"\n    };\n  } // dispatch(fetchBondInProgress());\n  // Calculate bond details.\n\n\n  const bondContract = bond.getContractForBond(networkID, provider);\n  const reserveContract = bond.getContractForReserve(networkID, provider);\n  let pendingPayout, bondMaturationBlock;\n  const bondDetails = await bondContract.bondInfo(address);\n  let interestDue = Number(bondDetails.payout.toString()) / Math.pow(10, 9);\n  bondMaturationBlock = +bondDetails.vesting + +bondDetails.lastBlock;\n  pendingPayout = await bondContract.pendingPayoutFor(address);\n  let allowance,\n      balance = BigNumber.from(0);\n  allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n  balance = await reserveContract.balanceOf(address); // formatEthers takes BigNumber => String\n\n  const balanceVal = ethers.utils.formatEther(balance); // balanceVal should NOT be converted to a number. it loses decimal precision\n\n  return {\n    bond: bond.name,\n    displayName: bond.displayName,\n    bondIconSvg: bond.bondIconSvg,\n    isLP: bond.isLP,\n    allowance: Number(allowance.toString()),\n    balance: balanceVal,\n    interestDue,\n    bondMaturationBlock,\n    pendingPayout: ethers.utils.formatUnits(pendingPayout, \"gwei\")\n  };\n});\nconst initialState = {\n  loading: false,\n  bonds: {},\n  balances: {\n    ohm: \"\",\n    sohm: \"\",\n    dai: \"\",\n    oldsohm: \"\"\n  }\n};\nconst accountSlice = createSlice({\n  name: \"account\",\n  initialState,\n  reducers: {\n    fetchAccountSuccess(state, action) {\n      setAll(state, action.payload);\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(loadAccountDetails.pending, state => {\n      state.loading = true;\n    }).addCase(loadAccountDetails.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(loadAccountDetails.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.log(error);\n    }).addCase(getBalances.pending, state => {\n      state.loading = true;\n    }).addCase(getBalances.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(getBalances.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.log(error);\n    }).addCase(calculateUserBondDetails.pending, state => {\n      state.loading = true;\n    }).addCase(calculateUserBondDetails.fulfilled, (state, action) => {\n      if (!action.payload) return;\n      const bond = action.payload.bond;\n      state.bonds[bond] = action.payload;\n      state.loading = false;\n    }).addCase(calculateUserBondDetails.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\nexport default accountSlice.reducer;\nexport const {\n  fetchAccountSuccess\n} = accountSlice.actions;\n\nconst baseInfo = state => state.account;\n\nexport const getAccountState = createSelector(baseInfo, account => account);","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/AccountSlice.ts"],"names":["BigNumber","ethers","addresses","abi","ierc20Abi","sOHMv2","wsOHM","setAll","createAsyncThunk","createSelector","createSlice","getBalances","address","networkID","provider","ohmBalance","from","sohmBalance","wsohmBalance","wsohmAsSohm","poolBalance","aguruBalance","OX_ADDRESS","ohmContract","Contract","balanceOf","SOX_ADDRESS","sohmContract","WSOX_ADDRESS","wsohmContract","wOHMTosOHM","PT_TOKEN_ADDRESS","poolTokenContract","AOX_ADDRESS","aguruContract","balances","ohm","utils","formatUnits","sohm","wsohm","formatEther","pool","aguru","loadAccountDetails","fsohmBalance","fsohmString","wrapAllowance","unwrapAllowance","stakeAllowance","unstakeAllowance","aguruAllowance","lpStaked","pendingRewards","lpBondAllowance","daiBondAllowance","aOHMAbleToClaim","poolAllowance","daiContract","DAI_ADDRESS","daiBalance","allowance","STAKING_HELPER_ADDRESS","STAKING_ADDRESS","CLAIM_ADDRESS","dai","fsohm","staking","ohmStake","ohmUnstake","claim","wrapping","ohmWrap","ohmUnwrap","bonding","daiAllowance","pooling","sohmPool","calculateUserBondDetails","bond","displayName","bondIconSvg","isLP","balance","interestDue","bondMaturationBlock","pendingPayout","bondContract","getContractForBond","reserveContract","getContractForReserve","bondDetails","bondInfo","Number","payout","toString","Math","pow","vesting","lastBlock","pendingPayoutFor","getAddressForBond","balanceVal","name","initialState","loading","bonds","oldsohm","accountSlice","reducers","fetchAccountSuccess","state","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","error","console","log","reducer","actions","baseInfo","account","getAccountState"],"mappings":"AAAA,SAASA,SAAT,EAAkCC,MAAlC,QAAgD,QAAhD;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,GAAG,IAAIC,SAAhB,QAAiC,oBAAjC;AACA,SAASD,GAAG,IAAIE,MAAhB,QAA8B,oBAA9B;AAEA,SAASF,GAAG,IAAIG,KAAhB,QAA6B,mBAA7B;AAEA,SAASC,MAAT,QAAuB,YAAvB;AAEA,SAASC,gBAAT,EAA2BC,cAA3B,EAA2CC,WAA3C,QAA8D,kBAA9D;AAKA,OAAO,MAAMC,WAAW,GAAGH,gBAAgB,CACzC,qBADyC,EAEzC,OAAO;AAAEI,EAAAA,OAAF;AAAWC,EAAAA,SAAX;AAAsBC,EAAAA;AAAtB,CAAP,KAAoE;AAClE,MAAIC,UAAU,GAAGf,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAjB;AACA,MAAIC,WAAW,GAAGjB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAlB;AACA,MAAIE,YAAY,GAAGlB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAnB;AACA,MAAIG,WAAW,GAAGnB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAlB;AACA,MAAII,WAAW,GAAGpB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAlB;AACA,MAAIK,YAAY,GAAGrB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAnB;;AACA,MAAId,SAAS,CAACW,SAAD,CAAT,CAAqBS,UAAzB,EAAqC;AACnC,UAAMC,WAAW,GAAG,IAAItB,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqBS,UAAzC,EAA+DlB,SAA/D,EAA0EU,QAA1E,CAApB;AACAC,IAAAA,UAAU,GAAG,MAAMQ,WAAW,CAACE,SAAZ,CAAsBb,OAAtB,CAAnB;AACD;;AAED,MAAIV,SAAS,CAACW,SAAD,CAAT,CAAqBa,WAAzB,EAAsC;AACpC,UAAMC,YAAY,GAAG,IAAI1B,MAAM,CAACuB,QAAX,CACnBtB,SAAS,CAACW,SAAD,CAAT,CAAqBa,WADF,EAEnBtB,SAFmB,EAGnBU,QAHmB,CAArB;AAKAG,IAAAA,WAAW,GAAG,MAAMU,YAAY,CAACF,SAAb,CAAuBb,OAAvB,CAApB;AACD;;AAED,MAAIV,SAAS,CAACW,SAAD,CAAT,CAAqBe,YAAzB,EAAuC;AACrC,UAAMC,aAAa,GAAG,IAAI5B,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqBe,YAAzC,EAAiEtB,KAAjE,EAAwEQ,QAAxE,CAAtB;AACAI,IAAAA,YAAY,GAAG,MAAMW,aAAa,CAACJ,SAAd,CAAwBb,OAAxB,CAArB,CAFqC,CAGrC;;AACAO,IAAAA,WAAW,GAAG,MAAMU,aAAa,CAACC,UAAd,CAAyBZ,YAAzB,CAApB;AACD;;AAED,MAAIhB,SAAS,CAACW,SAAD,CAAT,CAAqBkB,gBAAzB,EAA2C;AACzC,UAAMC,iBAAiB,GAAG,IAAI/B,MAAM,CAACuB,QAAX,CACxBtB,SAAS,CAACW,SAAD,CAAT,CAAqBkB,gBADG,EAExB3B,SAFwB,EAGxBU,QAHwB,CAA1B;AAKAM,IAAAA,WAAW,GAAG,MAAMY,iBAAiB,CAACP,SAAlB,CAA4Bb,OAA5B,CAApB;AACD;;AAED,MAAIV,SAAS,CAACW,SAAD,CAAT,CAAqBoB,WAAzB,EAAsC;AACpC,UAAMC,aAAa,GAAG,IAAIjC,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqBoB,WAAzC,EAAgE5B,MAAhE,EAAwES,QAAxE,CAAtB;AACAO,IAAAA,YAAY,GAAG,MAAMa,aAAa,CAACT,SAAd,CAAwBb,OAAxB,CAArB;AACD;;AAED,SAAO;AACLuB,IAAAA,QAAQ,EAAE;AACRC,MAAAA,GAAG,EAAEnC,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBvB,UAAzB,EAAqC,MAArC,CADG;AAERwB,MAAAA,IAAI,EAAEtC,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBrB,WAAzB,EAAsC,MAAtC,CAFE;AAGRuB,MAAAA,KAAK,EAAEvC,MAAM,CAACoC,KAAP,CAAaI,WAAb,CAAyBvB,YAAzB,CAHC;AAIRC,MAAAA,WAAW,EAAElB,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBnB,WAAzB,EAAsC,MAAtC,CAJL;AAKRuB,MAAAA,IAAI,EAAEzC,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBlB,WAAzB,EAAsC,MAAtC,CALE;AAMRuB,MAAAA,KAAK,EAAE1C,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBjB,YAAzB,EAAuC,MAAvC;AANC;AADL,GAAP;AAUD,CAtDwC,CAApC;AA8EP,OAAO,MAAMuB,kBAAkB,GAAGpC,gBAAgB,CAChD,4BADgD,EAEhD,OAAO;AAAEK,EAAAA,SAAF;AAAaC,EAAAA,QAAb;AAAuBF,EAAAA;AAAvB,CAAP,KAAoE;AAClE,MAAIG,UAAU,GAAGf,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAjB;AACA,MAAIC,WAAW,GAAGjB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAlB;AACA,MAAI6B,YAAY,GAAG7C,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAnB;AACA,MAAI8B,WAAW,GAAG,KAAlB;AACA,MAAI5B,YAAY,GAAGlB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAnB;AACA,MAAIG,WAAW,GAAGnB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAlB;AACA,MAAI+B,aAAa,GAAG/C,SAAS,CAACgB,IAAV,CAAe,CAAf,CAApB;AACA,MAAIgC,eAAe,GAAGhD,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAtB;AACA,MAAIiC,cAAc,GAAGjD,SAAS,CAACgB,IAAV,CAAe,CAAf,CAArB;AACA,MAAIkC,gBAAgB,GAAGlD,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAvB;AACA,MAAImC,cAAc,GAAGnD,SAAS,CAACgB,IAAV,CAAe,CAAf,CAArB;AACA,MAAIK,YAAY,GAAGrB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAnB;AACA,MAAIoC,QAAQ,GAAG,CAAf;AACA,MAAIC,cAAc,GAAG,CAArB;AACA,MAAIC,eAAe,GAAG,CAAtB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;AACA,MAAIC,eAAe,GAAG,CAAtB;AACA,MAAIpC,WAAW,GAAGpB,SAAS,CAACgB,IAAV,CAAe,CAAf,CAAlB;AACA,MAAIyC,aAAa,GAAGzD,SAAS,CAACgB,IAAV,CAAe,CAAf,CAApB;AAEA,QAAM0C,WAAW,GAAG,IAAIzD,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqB8C,WAAzC,EAAgEvD,SAAhE,EAA2EU,QAA3E,CAApB;AACA,QAAM8C,UAAU,GAAG,MAAMF,WAAW,CAACjC,SAAZ,CAAsBb,OAAtB,CAAzB;;AAEA,MAAIV,SAAS,CAACW,SAAD,CAAT,CAAqBS,UAAzB,EAAqC;AACnC,UAAMC,WAAW,GAAG,IAAItB,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqBS,UAAzC,EAA+DlB,SAA/D,EAA0EU,QAA1E,CAApB;AACAC,IAAAA,UAAU,GAAG,MAAMQ,WAAW,CAACE,SAAZ,CAAsBb,OAAtB,CAAnB;AACAqC,IAAAA,cAAc,GAAG,MAAM1B,WAAW,CAACsC,SAAZ,CAAsBjD,OAAtB,EAA+BV,SAAS,CAACW,SAAD,CAAT,CAAqBiD,sBAApD,CAAvB;AACD;;AAED,MAAI5D,SAAS,CAACW,SAAD,CAAT,CAAqBa,WAAzB,EAAsC;AACpC,UAAMC,YAAY,GAAG,IAAI1B,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqBa,WAAzC,EAAgErB,MAAhE,EAAwES,QAAxE,CAArB;AACAG,IAAAA,WAAW,GAAG,MAAMU,YAAY,CAACF,SAAb,CAAuBb,OAAvB,CAApB;AACAsC,IAAAA,gBAAgB,GAAG,MAAMvB,YAAY,CAACkC,SAAb,CAAuBjD,OAAvB,EAAgCV,SAAS,CAACW,SAAD,CAAT,CAAqBkD,eAArD,CAAzB,CAHoC,CAIpC;AACA;AACD;;AAED,MAAI7D,SAAS,CAACW,SAAD,CAAT,CAAqBoB,WAAzB,EAAsC;AACpC,UAAMC,aAAa,GAAG,IAAIjC,MAAM,CAACuB,QAAX,CAAoBtB,SAAS,CAACW,SAAD,CAAT,CAAqBoB,WAAzC,EAAgE5B,MAAhE,EAAwES,QAAxE,CAAtB;AACAO,IAAAA,YAAY,GAAG,MAAMa,aAAa,CAACT,SAAd,CAAwBb,OAAxB,CAArB;AACAuC,IAAAA,cAAc,GAAG,MAAMjB,aAAa,CAAC2B,SAAd,CAAwBjD,OAAxB,EAAiCV,SAAS,CAACW,SAAD,CAAT,CAAqBmD,aAAtD,CAAvB;AACD,GA1CiE,CA4ClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAO;AACL7B,IAAAA,QAAQ,EAAE;AACR8B,MAAAA,GAAG,EAAEhE,MAAM,CAACoC,KAAP,CAAaI,WAAb,CAAyBmB,UAAzB,CADG;AAERxB,MAAAA,GAAG,EAAEnC,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBvB,UAAzB,EAAqC,MAArC,CAFG;AAGRwB,MAAAA,IAAI,EAAEtC,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBrB,WAAzB,EAAsC,MAAtC,CAHE;AAIRiD,MAAAA,KAAK,EAAEjE,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBO,YAAzB,EAAuC,MAAvC,CAJC;AAKRL,MAAAA,KAAK,EAAEvC,MAAM,CAACoC,KAAP,CAAaI,WAAb,CAAyBvB,YAAzB,CALC;AAMRC,MAAAA,WAAW,EAAElB,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBnB,WAAzB,EAAsC,MAAtC,CANL;AAORuB,MAAAA,IAAI,EAAEzC,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBlB,WAAzB,EAAsC,MAAtC,CAPE;AAQRuB,MAAAA,KAAK,EAAE1C,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBjB,YAAzB,EAAuC,MAAvC;AARC,KADL;AAWL8C,IAAAA,OAAO,EAAE;AACPC,MAAAA,QAAQ,EAAE,CAACnB,cADJ;AAEPoB,MAAAA,UAAU,EAAE,CAACnB;AAFN,KAXJ;AAeLoB,IAAAA,KAAK,EAAE;AACLnB,MAAAA,cAAc,EAAEA;AADX,KAfF;AAkBLoB,IAAAA,QAAQ,EAAE;AACRC,MAAAA,OAAO,EAAE,CAACzB,aADF;AAER0B,MAAAA,SAAS,EAAE,CAACzB;AAFJ,KAlBL;AAsBL0B,IAAAA,OAAO,EAAE;AACPC,MAAAA,YAAY,EAAEpB;AADP,KAtBJ;AAyBLqB,IAAAA,OAAO,EAAE;AACPC,MAAAA,QAAQ,EAAE,CAACpB;AADJ;AAzBJ,GAAP;AA6BD,CA7G+C,CAA3C;AAsHP,OAAO,MAAMqB,wBAAwB,GAAGtE,gBAAgB,CACtD,kCADsD,EAEtD,OAAO;AAAEI,EAAAA,OAAF;AAAWmE,EAAAA,IAAX;AAAiBlE,EAAAA,SAAjB;AAA4BC,EAAAA;AAA5B,CAAP,KAAkF;AAChF,MAAI,CAACF,OAAL,EAAc;AACZ,WAAO;AACLmE,MAAAA,IAAI,EAAE,EADD;AAELC,MAAAA,WAAW,EAAE,EAFR;AAGLC,MAAAA,WAAW,EAAE,EAHR;AAILC,MAAAA,IAAI,EAAE,KAJD;AAKLrB,MAAAA,SAAS,EAAE,CALN;AAMLsB,MAAAA,OAAO,EAAE,GANJ;AAOLC,MAAAA,WAAW,EAAE,CAPR;AAQLC,MAAAA,mBAAmB,EAAE,CARhB;AASLC,MAAAA,aAAa,EAAE;AATV,KAAP;AAWD,GAb+E,CAchF;AAEA;;;AACA,QAAMC,YAAY,GAAGR,IAAI,CAACS,kBAAL,CAAwB3E,SAAxB,EAAmCC,QAAnC,CAArB;AACA,QAAM2E,eAAe,GAAGV,IAAI,CAACW,qBAAL,CAA2B7E,SAA3B,EAAsCC,QAAtC,CAAxB;AAEA,MAAIwE,aAAJ,EAAmBD,mBAAnB;AAEA,QAAMM,WAAW,GAAG,MAAMJ,YAAY,CAACK,QAAb,CAAsBhF,OAAtB,CAA1B;AACA,MAAIwE,WAAyB,GAAGS,MAAM,CAACF,WAAW,CAACG,MAAZ,CAAmBC,QAAnB,EAAD,CAAN,GAAwCC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAa,CAAb,CAAxE;AACAZ,EAAAA,mBAAmB,GAAG,CAACM,WAAW,CAACO,OAAb,GAAuB,CAACP,WAAW,CAACQ,SAA1D;AACAb,EAAAA,aAAa,GAAG,MAAMC,YAAY,CAACa,gBAAb,CAA8BxF,OAA9B,CAAtB;AAEA,MAAIiD,SAAJ;AAAA,MACEsB,OAAO,GAAGnF,SAAS,CAACgB,IAAV,CAAe,CAAf,CADZ;AAEA6C,EAAAA,SAAS,GAAG,MAAM4B,eAAe,CAAC5B,SAAhB,CAA0BjD,OAA1B,EAAmCmE,IAAI,CAACsB,iBAAL,CAAuBxF,SAAvB,CAAnC,CAAlB;AACAsE,EAAAA,OAAO,GAAG,MAAMM,eAAe,CAAChE,SAAhB,CAA0Bb,OAA1B,CAAhB,CA9BgF,CA+BhF;;AACA,QAAM0F,UAAU,GAAGrG,MAAM,CAACoC,KAAP,CAAaI,WAAb,CAAyB0C,OAAzB,CAAnB,CAhCgF,CAiChF;;AACA,SAAO;AACLJ,IAAAA,IAAI,EAAEA,IAAI,CAACwB,IADN;AAELvB,IAAAA,WAAW,EAAED,IAAI,CAACC,WAFb;AAGLC,IAAAA,WAAW,EAAEF,IAAI,CAACE,WAHb;AAILC,IAAAA,IAAI,EAAEH,IAAI,CAACG,IAJN;AAKLrB,IAAAA,SAAS,EAAEgC,MAAM,CAAChC,SAAS,CAACkC,QAAV,EAAD,CALZ;AAMLZ,IAAAA,OAAO,EAAEmB,UANJ;AAOLlB,IAAAA,WAPK;AAQLC,IAAAA,mBARK;AASLC,IAAAA,aAAa,EAAErF,MAAM,CAACoC,KAAP,CAAaC,WAAb,CAAyBgD,aAAzB,EAAwC,MAAxC;AATV,GAAP;AAWD,CA/CqD,CAAjD;AA4DP,MAAMkB,YAA2B,GAAG;AAClCC,EAAAA,OAAO,EAAE,KADyB;AAElCC,EAAAA,KAAK,EAAE,EAF2B;AAGlCvE,EAAAA,QAAQ,EAAE;AAAEC,IAAAA,GAAG,EAAE,EAAP;AAAWG,IAAAA,IAAI,EAAE,EAAjB;AAAqB0B,IAAAA,GAAG,EAAE,EAA1B;AAA8B0C,IAAAA,OAAO,EAAE;AAAvC;AAHwB,CAApC;AAMA,MAAMC,YAAY,GAAGlG,WAAW,CAAC;AAC/B6F,EAAAA,IAAI,EAAE,SADyB;AAE/BC,EAAAA,YAF+B;AAG/BK,EAAAA,QAAQ,EAAE;AACRC,IAAAA,mBAAmB,CAACC,KAAD,EAAQC,MAAR,EAAgB;AACjCzG,MAAAA,MAAM,CAACwG,KAAD,EAAQC,MAAM,CAACC,OAAf,CAAN;AACD;;AAHO,GAHqB;AAQ/BC,EAAAA,aAAa,EAAEC,OAAO,IAAI;AACxBA,IAAAA,OAAO,CACJC,OADH,CACWxE,kBAAkB,CAACyE,OAD9B,EACuCN,KAAK,IAAI;AAC5CA,MAAAA,KAAK,CAACN,OAAN,GAAgB,IAAhB;AACD,KAHH,EAIGW,OAJH,CAIWxE,kBAAkB,CAAC0E,SAJ9B,EAIyC,CAACP,KAAD,EAAQC,MAAR,KAAmB;AACxDzG,MAAAA,MAAM,CAACwG,KAAD,EAAQC,MAAM,CAACC,OAAf,CAAN;AACAF,MAAAA,KAAK,CAACN,OAAN,GAAgB,KAAhB;AACD,KAPH,EAQGW,OARH,CAQWxE,kBAAkB,CAAC2E,QAR9B,EAQwC,CAACR,KAAD,EAAQ;AAAES,MAAAA;AAAF,KAAR,KAAsB;AAC1DT,MAAAA,KAAK,CAACN,OAAN,GAAgB,KAAhB;AACAgB,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD,KAXH,EAYGJ,OAZH,CAYWzG,WAAW,CAAC0G,OAZvB,EAYgCN,KAAK,IAAI;AACrCA,MAAAA,KAAK,CAACN,OAAN,GAAgB,IAAhB;AACD,KAdH,EAeGW,OAfH,CAeWzG,WAAW,CAAC2G,SAfvB,EAekC,CAACP,KAAD,EAAQC,MAAR,KAAmB;AACjDzG,MAAAA,MAAM,CAACwG,KAAD,EAAQC,MAAM,CAACC,OAAf,CAAN;AACAF,MAAAA,KAAK,CAACN,OAAN,GAAgB,KAAhB;AACD,KAlBH,EAmBGW,OAnBH,CAmBWzG,WAAW,CAAC4G,QAnBvB,EAmBiC,CAACR,KAAD,EAAQ;AAAES,MAAAA;AAAF,KAAR,KAAsB;AACnDT,MAAAA,KAAK,CAACN,OAAN,GAAgB,KAAhB;AACAgB,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD,KAtBH,EAuBGJ,OAvBH,CAuBWtC,wBAAwB,CAACuC,OAvBpC,EAuB6CN,KAAK,IAAI;AAClDA,MAAAA,KAAK,CAACN,OAAN,GAAgB,IAAhB;AACD,KAzBH,EA0BGW,OA1BH,CA0BWtC,wBAAwB,CAACwC,SA1BpC,EA0B+C,CAACP,KAAD,EAAQC,MAAR,KAAmB;AAC9D,UAAI,CAACA,MAAM,CAACC,OAAZ,EAAqB;AACrB,YAAMlC,IAAI,GAAGiC,MAAM,CAACC,OAAP,CAAelC,IAA5B;AACAgC,MAAAA,KAAK,CAACL,KAAN,CAAY3B,IAAZ,IAAoBiC,MAAM,CAACC,OAA3B;AACAF,MAAAA,KAAK,CAACN,OAAN,GAAgB,KAAhB;AACD,KA/BH,EAgCGW,OAhCH,CAgCWtC,wBAAwB,CAACyC,QAhCpC,EAgC8C,CAACR,KAAD,EAAQ;AAAES,MAAAA;AAAF,KAAR,KAAsB;AAChET,MAAAA,KAAK,CAACN,OAAN,GAAgB,KAAhB;AACAgB,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD,KAnCH;AAoCD;AA7C8B,CAAD,CAAhC;AAgDA,eAAeZ,YAAY,CAACe,OAA5B;AAEA,OAAO,MAAM;AAAEb,EAAAA;AAAF,IAA0BF,YAAY,CAACgB,OAA7C;;AAEP,MAAMC,QAAQ,GAAId,KAAD,IAAsBA,KAAK,CAACe,OAA7C;;AAEA,OAAO,MAAMC,eAAe,GAAGtH,cAAc,CAACoH,QAAD,EAAWC,OAAO,IAAIA,OAAtB,CAAtC","sourcesContent":["import { BigNumber, BigNumberish, ethers } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20Abi } from \"../abi/IERC20.json\";\nimport { abi as sOHMv2 } from \"../abi/sOhmv2.json\";\nimport { abi as fuseProxy } from \"../abi/FuseProxy.json\";\nimport { abi as wsOHM } from \"../abi/wsOHM.json\";\n\nimport { setAll } from \"../helpers\";\n\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { RootState } from \"src/store\";\nimport { IBaseAddressAsyncThunk, ICalcUserBondDetailsAsyncThunk } from \"./interfaces\";\nimport { FuseProxy, IERC20, SOhmv2, WsOHM } from \"src/typechain\";\n\nexport const getBalances = createAsyncThunk(\n  \"account/getBalances\",\n  async ({ address, networkID, provider }: IBaseAddressAsyncThunk) => {\n    let ohmBalance = BigNumber.from(0);\n    let sohmBalance = BigNumber.from(0);\n    let wsohmBalance = BigNumber.from(0);\n    let wsohmAsSohm = BigNumber.from(0);\n    let poolBalance = BigNumber.from(0);\n    let aguruBalance = BigNumber.from(0);\n    if (addresses[networkID].OX_ADDRESS) {\n      const ohmContract = new ethers.Contract(addresses[networkID].OX_ADDRESS as string, ierc20Abi, provider) as IERC20;\n      ohmBalance = await ohmContract.balanceOf(address);\n    }\n\n    if (addresses[networkID].SOX_ADDRESS) {\n      const sohmContract = new ethers.Contract(\n        addresses[networkID].SOX_ADDRESS as string,\n        ierc20Abi,\n        provider,\n      ) as IERC20;\n      sohmBalance = await sohmContract.balanceOf(address);\n    }\n\n    if (addresses[networkID].WSOX_ADDRESS) {\n      const wsohmContract = new ethers.Contract(addresses[networkID].WSOX_ADDRESS as string, wsOHM, provider) as WsOHM;\n      wsohmBalance = await wsohmContract.balanceOf(address);\n      // NOTE (appleseed): wsohmAsSohm is wsOHM given as a quantity of sOHM\n      wsohmAsSohm = await wsohmContract.wOHMTosOHM(wsohmBalance);\n    }\n\n    if (addresses[networkID].PT_TOKEN_ADDRESS) {\n      const poolTokenContract = new ethers.Contract(\n        addresses[networkID].PT_TOKEN_ADDRESS as string,\n        ierc20Abi,\n        provider,\n      ) as IERC20;\n      poolBalance = await poolTokenContract.balanceOf(address);\n    }\n\n    if (addresses[networkID].AOX_ADDRESS) {\n      const aguruContract = new ethers.Contract(addresses[networkID].AOX_ADDRESS as string, sOHMv2, provider) as SOhmv2;\n      aguruBalance = await aguruContract.balanceOf(address);\n    }\n\n    return {\n      balances: {\n        ohm: ethers.utils.formatUnits(ohmBalance, \"gwei\"),\n        sohm: ethers.utils.formatUnits(sohmBalance, \"gwei\"),\n        wsohm: ethers.utils.formatEther(wsohmBalance),\n        wsohmAsSohm: ethers.utils.formatUnits(wsohmAsSohm, \"gwei\"),\n        pool: ethers.utils.formatUnits(poolBalance, \"gwei\"),\n        aguru: ethers.utils.formatUnits(aguruBalance, \"gwei\"),\n      },\n    };\n  },\n);\n\ninterface IUserAccountDetails {\n  balances: {\n    dai: string;\n    ohm: string;\n    sohm: string;\n    wsohm: string;\n    wsohmAsSohm: string;\n  };\n  staking: {\n    ohmStake: number;\n    ohmUnstake: number;\n  };\n  wrapping: {\n    sohmWrap: number;\n    wsohmUnwrap: number;\n  };\n  bonding: {\n    daiAllowance: number;\n  };\n}\n\nexport const loadAccountDetails = createAsyncThunk(\n  \"account/loadAccountDetails\",\n  async ({ networkID, provider, address }: IBaseAddressAsyncThunk) => {\n    let ohmBalance = BigNumber.from(0);\n    let sohmBalance = BigNumber.from(0);\n    let fsohmBalance = BigNumber.from(0);\n    let fsohmString = \"0.0\";\n    let wsohmBalance = BigNumber.from(0);\n    let wsohmAsSohm = BigNumber.from(0);\n    let wrapAllowance = BigNumber.from(0);\n    let unwrapAllowance = BigNumber.from(0);\n    let stakeAllowance = BigNumber.from(0);\n    let unstakeAllowance = BigNumber.from(0);\n    let aguruAllowance = BigNumber.from(0);\n    let aguruBalance = BigNumber.from(0);\n    let lpStaked = 0;\n    let pendingRewards = 0;\n    let lpBondAllowance = 0;\n    let daiBondAllowance = 0;\n    let aOHMAbleToClaim = 0;\n    let poolBalance = BigNumber.from(0);\n    let poolAllowance = BigNumber.from(0);\n\n    const daiContract = new ethers.Contract(addresses[networkID].DAI_ADDRESS as string, ierc20Abi, provider) as IERC20;\n    const daiBalance = await daiContract.balanceOf(address);\n\n    if (addresses[networkID].OX_ADDRESS) {\n      const ohmContract = new ethers.Contract(addresses[networkID].OX_ADDRESS as string, ierc20Abi, provider) as IERC20;\n      ohmBalance = await ohmContract.balanceOf(address);\n      stakeAllowance = await ohmContract.allowance(address, addresses[networkID].STAKING_HELPER_ADDRESS);\n    }\n\n    if (addresses[networkID].SOX_ADDRESS) {\n      const sohmContract = new ethers.Contract(addresses[networkID].SOX_ADDRESS as string, sOHMv2, provider) as SOhmv2;\n      sohmBalance = await sohmContract.balanceOf(address);\n      unstakeAllowance = await sohmContract.allowance(address, addresses[networkID].STAKING_ADDRESS);\n      // poolAllowance = await sohmContract.allowance(address, addresses[networkID].PT_PRIZE_POOL_ADDRESS);\n      // wrapAllowance = await sohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n    }\n\n    if (addresses[networkID].AOX_ADDRESS) {\n      const aguruContract = new ethers.Contract(addresses[networkID].AOX_ADDRESS as string, sOHMv2, provider) as SOhmv2;\n      aguruBalance = await aguruContract.balanceOf(address);\n      aguruAllowance = await aguruContract.allowance(address, addresses[networkID].CLAIM_ADDRESS);\n    }\n\n    // if (addresses[networkID].PT_TOKEN_ADDRESS) {\n    //   const poolTokenContract = new ethers.Contract(\n    //     addresses[networkID].PT_TOKEN_ADDRESS,\n    //     ierc20Abi,\n    //     provider,\n    //   ) as IERC20;\n    //   poolBalance = await poolTokenContract.balanceOf(address);\n    // }\n\n    // for (const fuseAddressKey of [\"FUSE_6_SOHM\", \"FUSE_18_SOHM\"]) {\n    //   if (addresses[networkID][fuseAddressKey]) {\n    //     const fsohmContract = new ethers.Contract(\n    //       addresses[networkID][fuseAddressKey] as string,\n    //       fuseProxy,\n    //       provider.getSigner(),\n    //     ) as FuseProxy;\n    //     // fsohmContract.signer;\n    //     const balanceOfUnderlying = await fsohmContract.callStatic.balanceOfUnderlying(address);\n    //     fsohmBalance = balanceOfUnderlying.add(fsohmBalance);\n    //   }\n    // }\n\n    // if (addresses[networkID].WSOX_ADDRESS) {\n    //   const wsohmContract = new ethers.Contract(\n    //     addresses[networkID].WSOX_ADDRESS as string,\n    //     wsOHM,\n    //     provider,\n    //   ) as WsOHM;\n    //   wsohmBalance = await wsohmContract.balanceOf(address);\n    //   // NOTE (appleseed): wsohmAsSohm is used to calc your next reward amount\n    //   wsohmAsSohm = await wsohmContract.wOHMTosOHM(wsohmBalance);\n    //   unwrapAllowance = await wsohmContract.allowance(address, addresses[networkID].WSOX_ADDRESS);\n    // }\n\n    return {\n      balances: {\n        dai: ethers.utils.formatEther(daiBalance),\n        ohm: ethers.utils.formatUnits(ohmBalance, \"gwei\"),\n        sohm: ethers.utils.formatUnits(sohmBalance, \"gwei\"),\n        fsohm: ethers.utils.formatUnits(fsohmBalance, \"gwei\"),\n        wsohm: ethers.utils.formatEther(wsohmBalance),\n        wsohmAsSohm: ethers.utils.formatUnits(wsohmAsSohm, \"gwei\"),\n        pool: ethers.utils.formatUnits(poolBalance, \"gwei\"),\n        aguru: ethers.utils.formatUnits(aguruBalance, \"gwei\"),\n      },\n      staking: {\n        ohmStake: +stakeAllowance,\n        ohmUnstake: +unstakeAllowance,\n      },\n      claim: {\n        aguruAllowance: aguruAllowance,\n      },\n      wrapping: {\n        ohmWrap: +wrapAllowance,\n        ohmUnwrap: +unwrapAllowance,\n      },\n      bonding: {\n        daiAllowance: daiBondAllowance,\n      },\n      pooling: {\n        sohmPool: +poolAllowance,\n      },\n    };\n  },\n);\n\nexport interface IUserBondDetails {\n  allowance: number;\n  interestDue: number;\n  bondMaturationBlock: number;\n  pendingPayout: string; //Payout formatted in gwei.\n}\nexport const calculateUserBondDetails = createAsyncThunk(\n  \"account/calculateUserBondDetails\",\n  async ({ address, bond, networkID, provider }: ICalcUserBondDetailsAsyncThunk) => {\n    if (!address) {\n      return {\n        bond: \"\",\n        displayName: \"\",\n        bondIconSvg: \"\",\n        isLP: false,\n        allowance: 0,\n        balance: \"0\",\n        interestDue: 0,\n        bondMaturationBlock: 0,\n        pendingPayout: \"\",\n      };\n    }\n    // dispatch(fetchBondInProgress());\n\n    // Calculate bond details.\n    const bondContract = bond.getContractForBond(networkID, provider);\n    const reserveContract = bond.getContractForReserve(networkID, provider);\n\n    let pendingPayout, bondMaturationBlock;\n\n    const bondDetails = await bondContract.bondInfo(address);\n    let interestDue: BigNumberish = Number(bondDetails.payout.toString()) / Math.pow(10, 9);\n    bondMaturationBlock = +bondDetails.vesting + +bondDetails.lastBlock;\n    pendingPayout = await bondContract.pendingPayoutFor(address);\n\n    let allowance,\n      balance = BigNumber.from(0);\n    allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n    balance = await reserveContract.balanceOf(address);\n    // formatEthers takes BigNumber => String\n    const balanceVal = ethers.utils.formatEther(balance);\n    // balanceVal should NOT be converted to a number. it loses decimal precision\n    return {\n      bond: bond.name,\n      displayName: bond.displayName,\n      bondIconSvg: bond.bondIconSvg,\n      isLP: bond.isLP,\n      allowance: Number(allowance.toString()),\n      balance: balanceVal,\n      interestDue,\n      bondMaturationBlock,\n      pendingPayout: ethers.utils.formatUnits(pendingPayout, \"gwei\"),\n    };\n  },\n);\n\ninterface IAccountSlice {\n  bonds: { [key: string]: IUserBondDetails };\n  balances: {\n    ohm: string;\n    sohm: string;\n    dai: string;\n    oldsohm: string;\n  };\n  loading: boolean;\n}\nconst initialState: IAccountSlice = {\n  loading: false,\n  bonds: {},\n  balances: { ohm: \"\", sohm: \"\", dai: \"\", oldsohm: \"\" },\n};\n\nconst accountSlice = createSlice({\n  name: \"account\",\n  initialState,\n  reducers: {\n    fetchAccountSuccess(state, action) {\n      setAll(state, action.payload);\n    },\n  },\n  extraReducers: builder => {\n    builder\n      .addCase(loadAccountDetails.pending, state => {\n        state.loading = true;\n      })\n      .addCase(loadAccountDetails.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(loadAccountDetails.rejected, (state, { error }) => {\n        state.loading = false;\n        console.log(error);\n      })\n      .addCase(getBalances.pending, state => {\n        state.loading = true;\n      })\n      .addCase(getBalances.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(getBalances.rejected, (state, { error }) => {\n        state.loading = false;\n        console.log(error);\n      })\n      .addCase(calculateUserBondDetails.pending, state => {\n        state.loading = true;\n      })\n      .addCase(calculateUserBondDetails.fulfilled, (state, action) => {\n        if (!action.payload) return;\n        const bond = action.payload.bond;\n        state.bonds[bond] = action.payload;\n        state.loading = false;\n      })\n      .addCase(calculateUserBondDetails.rejected, (state, { error }) => {\n        state.loading = false;\n        console.log(error);\n      });\n  },\n});\n\nexport default accountSlice.reducer;\n\nexport const { fetchAccountSuccess } = accountSlice.actions;\n\nconst baseInfo = (state: RootState) => state.account;\n\nexport const getAccountState = createSelector(baseInfo, account => account);\n"]},"metadata":{},"sourceType":"module"}