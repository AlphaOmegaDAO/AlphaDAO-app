{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { abi as ierc20Abi } from \"src/abi/IERC20.json\";\nimport { getBondCalculator } from \"src/helpers/BondCalculator\";\nimport { addresses } from \"src/constants\";\nexport let NetworkID;\n\n(function (NetworkID) {\n  NetworkID[NetworkID[\"Mumbai\"] = 97] = \"Mumbai\";\n  NetworkID[NetworkID[\"Polygon\"] = 56] = \"Polygon\";\n})(NetworkID || (NetworkID = {}));\n\nexport let BondType;\n\n(function (BondType) {\n  BondType[BondType[\"StableAsset\"] = 0] = \"StableAsset\";\n  BondType[BondType[\"LP\"] = 1] = \"LP\";\n})(BondType || (BondType = {}));\n\n// Technically only exporting for the interface\nexport class Bond {\n  // Standard Bond fields regardless of LP bonds or stable bonds.\n  // Bond ABI\n  // The following two fields will differ on how they are set depending on bond type\n  // Token ABI\n  // Async method that returns a Promise\n  constructor(type, bondOpts) {\n    this.name = void 0;\n    this.displayName = void 0;\n    this.type = void 0;\n    this.isAvailable = void 0;\n    this.bondIconSvg = void 0;\n    this.bondContractABI = void 0;\n    this.networkAddrs = void 0;\n    this.bondToken = void 0;\n    this.isLP = void 0;\n    this.reserveContract = void 0;\n    this.displayUnits = void 0;\n    this.name = bondOpts.name;\n    this.displayName = bondOpts.displayName;\n    this.type = type;\n    this.isAvailable = bondOpts.isAvailable;\n    this.bondIconSvg = bondOpts.bondIconSvg;\n    this.bondContractABI = bondOpts.bondContractABI;\n    this.networkAddrs = bondOpts.networkAddrs;\n    this.bondToken = bondOpts.bondToken;\n  }\n  /**\n   * makes isAvailable accessible within Bonds.ts\n   * @param networkID\n   * @returns boolean\n   */\n\n\n  getAvailability(networkID) {\n    return this.isAvailable[networkID];\n  }\n\n  getAddressForBond(networkID) {\n    return this.networkAddrs[networkID].bondAddress;\n  }\n\n  getContractForBond(networkID, provider) {\n    const bondAddress = this.getAddressForBond(networkID);\n    return new ethers.Contract(bondAddress, this.bondContractABI, provider);\n  }\n\n  getAddressForReserve(networkID) {\n    var _this$networkAddrs$ne;\n\n    return (_this$networkAddrs$ne = this.networkAddrs[networkID]) === null || _this$networkAddrs$ne === void 0 ? void 0 : _this$networkAddrs$ne.reserveAddress;\n  }\n\n  getContractForReserve(networkID, provider) {\n    const bondAddress = this.getAddressForReserve(networkID);\n    return new ethers.Contract(bondAddress, this.reserveContract, provider);\n  }\n\n  async getBondReservePrice(networkID, provider) {\n    const pairContract = this.getContractForReserve(networkID, provider);\n    const reserves = await pairContract.getReserves();\n    const marketPrice = Number(reserves[1].toString()) / Number(reserves[0].toString()) / 10 ** 9;\n    return marketPrice;\n  }\n\n} // Keep all LP specific fields/logic within the LPBond class\n\nexport class LPBond extends Bond {\n  constructor(lpBondOpts) {\n    super(BondType.LP, lpBondOpts);\n    this.isLP = true;\n    this.lpUrl = void 0;\n    this.reserveContract = void 0;\n    this.displayUnits = void 0;\n    this.lpUrl = lpBondOpts.lpUrl;\n    this.reserveContract = lpBondOpts.reserveContract;\n    this.displayUnits = \"LP\";\n  }\n\n  async getTreasuryBalance(networkID, provider) {\n    const token = this.getContractForReserve(networkID, provider);\n    const tokenAddress = this.getAddressForReserve(networkID);\n    const bondCalculator = getBondCalculator(networkID, provider);\n    const tokenAmount = await token.balanceOf(addresses[networkID].TREASURY_ADDRESS);\n    const valuation = await bondCalculator.valuation(tokenAddress, tokenAmount);\n    const markdown = await bondCalculator.markdown(tokenAddress);\n    let tokenUSD = Number(valuation.toString()) / Math.pow(10, 9) * (Number(markdown.toString()) / Math.pow(10, 18));\n    return Number(tokenUSD.toString());\n  }\n\n} // Generic BondClass we should be using everywhere\n// Assumes the token being deposited follows the standard ERC20 spec\n\nexport class StableBond extends Bond {\n  constructor(stableBondOpts) {\n    super(BondType.StableAsset, stableBondOpts); // For stable bonds the display units are the same as the actual token\n\n    this.isLP = false;\n    this.reserveContract = void 0;\n    this.displayUnits = void 0;\n    this.displayUnits = stableBondOpts.displayName;\n    this.reserveContract = ierc20Abi; // The Standard ierc20Abi since they're normal tokens\n  }\n\n  async getTreasuryBalance(networkID, provider) {\n    let token = this.getContractForReserve(networkID, provider);\n    console.log(\"token\", token);\n    let tokenAmount = await token.balanceOf(addresses[networkID].TREASURY_ADDRESS);\n    console.log(\"tokenAmount\", tokenAmount);\n    return Number(tokenAmount.toString()) / Math.pow(10, 18);\n  }\n\n} // These are special bonds that have different valuation methods\n\nexport class CustomBond extends Bond {\n  getTreasuryBalance(networkID, provider) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  constructor(customBondOpts) {\n    super(customBondOpts.bondType, customBondOpts);\n    this.isLP = void 0;\n    this.reserveContract = void 0;\n    this.displayUnits = void 0;\n    this.lpUrl = void 0;\n\n    if (customBondOpts.bondType === BondType.LP) {\n      this.isLP = true;\n    } else {\n      this.isLP = false;\n    }\n\n    this.lpUrl = customBondOpts.lpUrl; // For stable bonds the display units are the same as the actual token\n\n    this.displayUnits = customBondOpts.displayName;\n    this.reserveContract = customBondOpts.reserveContract;\n    this.getTreasuryBalance = customBondOpts.customTreasuryBalanceFunc.bind(this);\n  }\n\n}","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/lib/Bond.ts"],"names":["ethers","abi","ierc20Abi","getBondCalculator","addresses","NetworkID","BondType","Bond","constructor","type","bondOpts","name","displayName","isAvailable","bondIconSvg","bondContractABI","networkAddrs","bondToken","isLP","reserveContract","displayUnits","getAvailability","networkID","getAddressForBond","bondAddress","getContractForBond","provider","Contract","getAddressForReserve","reserveAddress","getContractForReserve","getBondReservePrice","pairContract","reserves","getReserves","marketPrice","Number","toString","LPBond","lpBondOpts","LP","lpUrl","getTreasuryBalance","token","tokenAddress","bondCalculator","tokenAmount","balanceOf","TREASURY_ADDRESS","valuation","markdown","tokenUSD","Math","pow","StableBond","stableBondOpts","StableAsset","console","log","CustomBond","Error","customBondOpts","bondType","customTreasuryBalanceFunc","bind"],"mappings":"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","sourcesContent":["import { StaticJsonRpcProvider, JsonRpcSigner } from \"@ethersproject/providers\";\nimport { ethers } from \"ethers\";\n\nimport { abi as ierc20Abi } from \"src/abi/IERC20.json\";\nimport { getBondCalculator } from \"src/helpers/BondCalculator\";\nimport { EthContract, PairContract } from \"src/typechain\";\nimport { addresses } from \"src/constants\";\nimport React from \"react\";\n\nexport enum NetworkID {\n  Mumbai = 97,\n  Polygon = 56,\n}\n\nexport enum BondType {\n  StableAsset,\n  LP,\n}\n\nexport interface BondAddresses {\n  reserveAddress: string;\n  bondAddress: string;\n}\n\nexport interface NetworkAddresses {\n  [NetworkID.Mumbai]: BondAddresses;\n  [NetworkID.Polygon]: BondAddresses;\n}\n\nexport interface Available {\n  [NetworkID.Mumbai]?: boolean;\n  [NetworkID.Polygon]?: boolean;\n}\n\ninterface BondOpts {\n  name: string; // Internal name used for references\n  displayName: string; // Displayname on UI\n  isAvailable: Available; // set false to hide\n  bondIconSvg: React.ReactNode; //  SVG path for icons\n  bondContractABI: ethers.ContractInterface; // ABI for contract\n  networkAddrs: NetworkAddresses; // Mapping of network --> Addresses\n  bondToken: string; // Unused, but native token to buy the bond.\n}\n\n// Technically only exporting for the interface\nexport abstract class Bond {\n  // Standard Bond fields regardless of LP bonds or stable bonds.\n  readonly name: string;\n  readonly displayName: string;\n  readonly type: BondType;\n  readonly isAvailable: Available;\n  readonly bondIconSvg: React.ReactNode;\n  readonly bondContractABI: ethers.ContractInterface; // Bond ABI\n  readonly networkAddrs: NetworkAddresses;\n  readonly bondToken: string;\n\n  // The following two fields will differ on how they are set depending on bond type\n  abstract isLP: Boolean;\n  abstract reserveContract: ethers.ContractInterface; // Token ABI\n  abstract displayUnits: string;\n\n  // Async method that returns a Promise\n  abstract getTreasuryBalance(networkID: NetworkID, provider: StaticJsonRpcProvider): Promise<number>;\n\n  constructor(type: BondType, bondOpts: BondOpts) {\n    this.name = bondOpts.name;\n    this.displayName = bondOpts.displayName;\n    this.type = type;\n    this.isAvailable = bondOpts.isAvailable;\n    this.bondIconSvg = bondOpts.bondIconSvg;\n    this.bondContractABI = bondOpts.bondContractABI;\n    this.networkAddrs = bondOpts.networkAddrs;\n    this.bondToken = bondOpts.bondToken;\n  }\n\n  /**\n   * makes isAvailable accessible within Bonds.ts\n   * @param networkID\n   * @returns boolean\n   */\n  getAvailability(networkID: NetworkID) {\n    return this.isAvailable[networkID];\n  }\n\n  getAddressForBond(networkID: NetworkID) {\n    return this.networkAddrs[networkID].bondAddress;\n  }\n  getContractForBond(networkID: NetworkID, provider: StaticJsonRpcProvider | JsonRpcSigner) {\n    const bondAddress = this.getAddressForBond(networkID);\n    return new ethers.Contract(bondAddress, this.bondContractABI, provider) as EthContract;\n  }\n\n  getAddressForReserve(networkID: NetworkID) {\n    return this.networkAddrs[networkID]?.reserveAddress;\n  }\n  getContractForReserve(networkID: NetworkID, provider: StaticJsonRpcProvider | JsonRpcSigner) {\n    const bondAddress = this.getAddressForReserve(networkID);\n    return new ethers.Contract(bondAddress, this.reserveContract, provider) as PairContract;\n  }\n\n  async getBondReservePrice(networkID: NetworkID, provider: StaticJsonRpcProvider | JsonRpcSigner) {\n    const pairContract = this.getContractForReserve(networkID, provider);\n    const reserves = await pairContract.getReserves();\n    const marketPrice = Number(reserves[1].toString()) / Number(reserves[0].toString()) / 10 ** 9;\n    return marketPrice;\n  }\n}\n\n// Keep all LP specific fields/logic within the LPBond class\nexport interface LPBondOpts extends BondOpts {\n  reserveContract: ethers.ContractInterface;\n  lpUrl: string;\n}\n\nexport class LPBond extends Bond {\n  readonly isLP = true;\n  readonly lpUrl: string;\n  readonly reserveContract: ethers.ContractInterface;\n  readonly displayUnits: string;\n\n  constructor(lpBondOpts: LPBondOpts) {\n    super(BondType.LP, lpBondOpts);\n\n    this.lpUrl = lpBondOpts.lpUrl;\n    this.reserveContract = lpBondOpts.reserveContract;\n    this.displayUnits = \"LP\";\n  }\n  async getTreasuryBalance(networkID: NetworkID, provider: StaticJsonRpcProvider) {\n    const token = this.getContractForReserve(networkID, provider);\n    const tokenAddress = this.getAddressForReserve(networkID);\n    const bondCalculator = getBondCalculator(networkID, provider);\n    const tokenAmount = await token.balanceOf(addresses[networkID].TREASURY_ADDRESS);\n    const valuation = await bondCalculator.valuation(tokenAddress, tokenAmount);\n    const markdown = await bondCalculator.markdown(tokenAddress);\n    let tokenUSD = (Number(valuation.toString()) / Math.pow(10, 9)) * (Number(markdown.toString()) / Math.pow(10, 18));\n    return Number(tokenUSD.toString());\n  }\n}\n\n// Generic BondClass we should be using everywhere\n// Assumes the token being deposited follows the standard ERC20 spec\nexport interface StableBondOpts extends BondOpts {}\nexport class StableBond extends Bond {\n  readonly isLP = false;\n  readonly reserveContract: ethers.ContractInterface;\n  readonly displayUnits: string;\n\n  constructor(stableBondOpts: StableBondOpts) {\n    super(BondType.StableAsset, stableBondOpts);\n    // For stable bonds the display units are the same as the actual token\n    this.displayUnits = stableBondOpts.displayName;\n    this.reserveContract = ierc20Abi; // The Standard ierc20Abi since they're normal tokens\n  }\n\n  async getTreasuryBalance(networkID: NetworkID, provider: StaticJsonRpcProvider) {\n    let token = this.getContractForReserve(networkID, provider);\n    console.log(\"token\", token);\n    let tokenAmount = await token.balanceOf(addresses[networkID].TREASURY_ADDRESS);\n    console.log(\"tokenAmount\", tokenAmount);\n    return Number(tokenAmount.toString()) / Math.pow(10, 18);\n  }\n}\n\n// These are special bonds that have different valuation methods\nexport interface CustomBondOpts extends BondOpts {\n  reserveContract: ethers.ContractInterface;\n  bondType: number;\n  lpUrl: string;\n  customTreasuryBalanceFunc: (\n    this: CustomBond,\n    networkID: NetworkID,\n    provider: StaticJsonRpcProvider,\n  ) => Promise<number>;\n}\nexport class CustomBond extends Bond {\n  readonly isLP: Boolean;\n  getTreasuryBalance(networkID: NetworkID, provider: StaticJsonRpcProvider): Promise<number> {\n    throw new Error(\"Method not implemented.\");\n  }\n  readonly reserveContract: ethers.ContractInterface;\n  readonly displayUnits: string;\n  readonly lpUrl: string;\n\n  constructor(customBondOpts: CustomBondOpts) {\n    super(customBondOpts.bondType, customBondOpts);\n\n    if (customBondOpts.bondType === BondType.LP) {\n      this.isLP = true;\n    } else {\n      this.isLP = false;\n    }\n    this.lpUrl = customBondOpts.lpUrl;\n    // For stable bonds the display units are the same as the actual token\n    this.displayUnits = customBondOpts.displayName;\n    this.reserveContract = customBondOpts.reserveContract;\n    this.getTreasuryBalance = customBondOpts.customTreasuryBalanceFunc.bind(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}