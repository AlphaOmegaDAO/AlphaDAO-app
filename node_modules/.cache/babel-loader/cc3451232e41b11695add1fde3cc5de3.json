{"ast":null,"code":"import { ethers, BigNumber } from \"ethers\";\nimport { contractForRedeemHelper } from \"../helpers\";\nimport { getBalances, calculateUserBondDetails } from \"./AccountSlice\";\nimport { findOrLoadMarketPrice } from \"./AppSlice\";\nimport { error, info } from \"./MessagesSlice\";\nimport { clearPendingTxn, fetchPendingTxns } from \"./PendingTxnsSlice\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { getBondCalculator } from \"src/helpers/BondCalculator\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\nexport const changeApproval = createAsyncThunk(\"bonding/changeApproval\", async ({\n  address,\n  bond,\n  provider,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const reserveContract = bond.getContractForReserve(networkID, signer);\n  const bondAddr = bond.getAddressForBond(networkID);\n  let approveTx;\n  let bondAllowance = await reserveContract.allowance(address, bondAddr); // return early if approval already exists\n\n  if (bondAllowance.gt(BigNumber.from(\"0\"))) {\n    dispatch(info(\"Approval completed.\"));\n    dispatch(calculateUserBondDetails({\n      address,\n      bond,\n      networkID,\n      provider\n    }));\n    return;\n  }\n\n  try {\n    approveTx = await reserveContract.approve(bondAddr, ethers.utils.parseUnits(\"1000000000\", \"ether\").toString());\n    dispatch(fetchPendingTxns({\n      txnHash: approveTx.hash,\n      text: \"Approving \" + bond.displayName,\n      type: \"approve_\" + bond.name\n    }));\n    await approveTx.wait();\n  } catch (e) {\n    dispatch(error(e.message));\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n      dispatch(calculateUserBondDetails({\n        address,\n        bond,\n        networkID,\n        provider\n      }));\n    }\n  }\n});\nexport const calcBondDetails = createAsyncThunk(\"bonding/calcBondDetails\", async ({\n  bond,\n  value,\n  provider,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!value) {\n    value = \"0\";\n  }\n\n  const amountInWei = ethers.utils.parseEther(value); // const vestingTerm = VESTING_TERM; // hardcoded for now\n\n  let bondPrice = BigNumber.from(0),\n      bondDiscount = 0,\n      valuation = 0,\n      bondQuote = BigNumber.from(0);\n  const bondContract = bond.getContractForBond(networkID, provider);\n  const bondCalcContract = getBondCalculator(networkID, provider);\n  const terms = await bondContract.terms();\n  const maxBondPrice = await bondContract.maxPayout();\n  let debtRatio = await bondContract.standardizedDebtRatio();\n  debtRatio = Number(debtRatio.toString()) / Math.pow(10, 9);\n  let marketPrice = 0;\n\n  try {\n    const originalPromiseResult = await dispatch(findOrLoadMarketPrice({\n      networkID: networkID,\n      provider: provider\n    })).unwrap();\n    marketPrice = originalPromiseResult === null || originalPromiseResult === void 0 ? void 0 : originalPromiseResult.marketPrice;\n  } catch (rejectedValueOrSerializedError) {\n    // handle error here\n    console.error(\"Returned a null response from dispatch(loadMarketPrice)\");\n  }\n\n  try {\n    bondPrice = await bondContract.bondPriceInUSD(); // bondDiscount = (marketPrice * Math.pow(10, 9) - bondPrice) / bondPrice; // 1 - bondPrice / (bondPrice * Math.pow(10, 9));\n\n    bondDiscount = (marketPrice * Math.pow(10, 18) - Number(bondPrice.toString())) / Number(bondPrice.toString()); // 1 - bondPrice / (bondPrice * Math.pow(10, 9));\n  } catch (e) {\n    console.log(\"error getting bondPriceInUSD\", e);\n  }\n\n  if (Number(value) === 0) {\n    // if inputValue is 0 avoid the bondQuote calls\n    bondQuote = BigNumber.from(0);\n  } else if (bond.isLP) {\n    valuation = Number((await bondCalcContract.valuation(bond.getAddressForReserve(networkID), amountInWei)).toString());\n    bondQuote = await bondContract.payoutFor(valuation);\n\n    if (!amountInWei.isZero() && Number(bondQuote.toString()) < 100000) {\n      bondQuote = BigNumber.from(0);\n      const errorString = \"Amount is too small!\";\n      dispatch(error(errorString));\n    } else {\n      bondQuote = Number(bondQuote.toString()) / Math.pow(10, 9);\n    }\n  } else {\n    // RFV = DAI\n    bondQuote = await bondContract.payoutFor(amountInWei);\n\n    if (!amountInWei.isZero() && Number(bondQuote.toString()) < 100000000000000) {\n      bondQuote = BigNumber.from(0);\n      const errorString = \"Amount is too small!\";\n      dispatch(error(errorString));\n    } else {\n      bondQuote = Number(bondQuote.toString()) / Math.pow(10, 18);\n    }\n  } // Display error if user tries to exceed maximum.\n\n\n  if (!!value && parseFloat(bondQuote.toString()) > Number(maxBondPrice.toString()) / Math.pow(10, 9)) {\n    const errorString = \"You're trying to bond more than the maximum payout available! The maximum bond payout is \" + (Number(maxBondPrice.toString()) / Math.pow(10, 9)).toFixed(2).toString() + \" OHM.\";\n    dispatch(error(errorString));\n  } // Calculate bonds purchased\n\n\n  let purchased = await bond.getTreasuryBalance(networkID, provider);\n  return {\n    bond: bond.name,\n    bondDiscount,\n    debtRatio: Number(debtRatio.toString()),\n    bondQuote: Number(bondQuote.toString()),\n    purchased,\n    vestingTerm: Number(terms.vestingTerm.toString()),\n    maxBondPrice: Number(maxBondPrice.toString()) / Math.pow(10, 9),\n    bondPrice: Number(bondPrice.toString()) / Math.pow(10, 18),\n    marketPrice: marketPrice\n  };\n});\nexport const bondAsset = createAsyncThunk(\"bonding/bondAsset\", async ({\n  value,\n  address,\n  bond,\n  networkID,\n  provider,\n  slippage\n}, {\n  dispatch\n}) => {\n  const depositorAddress = address;\n  const acceptedSlippage = slippage / 100 || 0.005; // 0.5% as default\n  // parseUnits takes String => BigNumber\n\n  console.log(\"value\", value);\n  const valueInWei = ethers.utils.parseUnits(value.toString(), \"ether\");\n  console.log(\"amount\", valueInWei.toString());\n  let balance; // Calculate maxPremium based on premium and slippage.\n  // const calculatePremium = await bonding.calculatePremium();\n\n  const signer = provider.getSigner();\n  const bondContract = bond.getContractForBond(networkID, signer);\n  const calculatePremium = await bondContract.bondPrice();\n  const maxPremium = Math.round(Number(calculatePremium.toString()) * (1 + acceptedSlippage));\n  console.log(\"maxPremium\", maxPremium);\n  console.log(\"depositorAddress\", depositorAddress); // Deposit the bond\n\n  let bondTx;\n  let uaData = {\n    address: address,\n    value: value,\n    type: \"Bond\",\n    bondName: bond.displayName,\n    approved: true,\n    txHash: \"\"\n  };\n\n  try {\n    bondTx = await bondContract.deposit(valueInWei, maxPremium, depositorAddress);\n    dispatch(fetchPendingTxns({\n      txnHash: bondTx.hash,\n      text: \"Bonding \" + bond.displayName,\n      type: \"bond_\" + bond.name\n    }));\n    uaData.txHash = bondTx.hash;\n    await bondTx.wait(); // TODO: it may make more sense to only have it in the finally.\n    // UX preference (show pending after txn complete or after balance updated)\n\n    dispatch(calculateUserBondDetails({\n      address,\n      bond,\n      networkID,\n      provider\n    }));\n  } catch (e) {\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to bond more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else dispatch(error(rpcError.message));\n  } finally {\n    if (bondTx) {\n      segmentUA(uaData);\n      dispatch(clearPendingTxn(bondTx.hash));\n    }\n  }\n});\nexport const redeemBond = createAsyncThunk(\"bonding/redeemBond\", async ({\n  address,\n  bond,\n  networkID,\n  provider,\n  autostake\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const bondContract = bond.getContractForBond(networkID, signer);\n  let redeemTx;\n  let uaData = {\n    address: address,\n    type: \"Redeem\",\n    bondName: bond.displayName,\n    autoStake: autostake,\n    approved: true,\n    txHash: \"\"\n  };\n\n  try {\n    redeemTx = await bondContract.redeem(address, autostake === true);\n    const pendingTxnType = \"redeem_bond_\" + bond + (autostake === true ? \"_autostake\" : \"\");\n    uaData.txHash = redeemTx.hash;\n    dispatch(fetchPendingTxns({\n      txnHash: redeemTx.hash,\n      text: \"Redeeming \" + bond.displayName,\n      type: pendingTxnType\n    }));\n    await redeemTx.wait();\n    await dispatch(calculateUserBondDetails({\n      address,\n      bond,\n      networkID,\n      provider\n    }));\n    dispatch(getBalances({\n      address,\n      networkID,\n      provider\n    }));\n  } catch (e) {\n    uaData.approved = false;\n    dispatch(error(e.message));\n  } finally {\n    if (redeemTx) {\n      segmentUA(uaData);\n      dispatch(clearPendingTxn(redeemTx.hash));\n    }\n  }\n});\nexport const redeemAllBonds = createAsyncThunk(\"bonding/redeemAllBonds\", async ({\n  bonds,\n  address,\n  networkID,\n  provider,\n  autostake\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const redeemHelperContract = contractForRedeemHelper({\n    networkID,\n    provider: signer\n  });\n  let redeemAllTx;\n\n  try {\n    redeemAllTx = await redeemHelperContract.redeemAll(address, autostake);\n    const pendingTxnType = \"redeem_all_bonds\" + (autostake === true ? \"_autostake\" : \"\");\n    await dispatch(fetchPendingTxns({\n      txnHash: redeemAllTx.hash,\n      text: \"Redeeming All Bonds\",\n      type: pendingTxnType\n    }));\n    await redeemAllTx.wait();\n    bonds && bonds.forEach(async bond => {\n      dispatch(calculateUserBondDetails({\n        address,\n        bond,\n        networkID,\n        provider\n      }));\n    });\n    dispatch(getBalances({\n      address,\n      networkID,\n      provider\n    }));\n  } catch (e) {\n    dispatch(error(e.message));\n  } finally {\n    if (redeemAllTx) {\n      dispatch(clearPendingTxn(redeemAllTx.hash));\n    }\n  }\n}); // Note(zx): this is a barebones interface for the state. Update to be more accurate\n\nconst setBondState = (state, payload) => {\n  const bond = payload.bond;\n  const newState = { ...state[bond],\n    ...payload\n  };\n  state[bond] = newState;\n  state.loading = false;\n};\n\nconst initialState = {\n  status: \"idle\"\n};\nconst bondingSlice = createSlice({\n  name: \"bonding\",\n  initialState,\n  reducers: {\n    fetchBondSuccess(state, action) {\n      state[action.payload.bond] = action.payload;\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(calcBondDetails.pending, state => {\n      state.loading = true;\n    }).addCase(calcBondDetails.fulfilled, (state, action) => {\n      setBondState(state, action.payload);\n      state.loading = false;\n    }).addCase(calcBondDetails.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.error(error.message);\n    });\n  }\n});\nexport default bondingSlice.reducer;\nexport const {\n  fetchBondSuccess\n} = bondingSlice.actions;\n\nconst baseInfo = state => state.bonding;\n\nexport const getBondingState = createSelector(baseInfo, bonding => bonding);","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/BondSlice.ts"],"names":["ethers","BigNumber","contractForRedeemHelper","getBalances","calculateUserBondDetails","findOrLoadMarketPrice","error","info","clearPendingTxn","fetchPendingTxns","createAsyncThunk","createSelector","createSlice","getBondCalculator","segmentUA","changeApproval","address","bond","provider","networkID","dispatch","signer","getSigner","reserveContract","getContractForReserve","bondAddr","getAddressForBond","approveTx","bondAllowance","allowance","gt","from","approve","utils","parseUnits","toString","txnHash","hash","text","displayName","type","name","wait","e","message","calcBondDetails","value","amountInWei","parseEther","bondPrice","bondDiscount","valuation","bondQuote","bondContract","getContractForBond","bondCalcContract","terms","maxBondPrice","maxPayout","debtRatio","standardizedDebtRatio","Number","Math","pow","marketPrice","originalPromiseResult","unwrap","rejectedValueOrSerializedError","console","bondPriceInUSD","log","isLP","getAddressForReserve","payoutFor","isZero","errorString","parseFloat","toFixed","purchased","getTreasuryBalance","vestingTerm","bondAsset","slippage","depositorAddress","acceptedSlippage","valueInWei","balance","calculatePremium","maxPremium","round","bondTx","uaData","bondName","approved","txHash","deposit","rpcError","code","indexOf","redeemBond","autostake","redeemTx","autoStake","redeem","pendingTxnType","redeemAllBonds","bonds","redeemHelperContract","redeemAllTx","redeemAll","forEach","setBondState","state","payload","newState","loading","initialState","status","bondingSlice","reducers","fetchBondSuccess","action","extraReducers","builder","addCase","pending","fulfilled","rejected","reducer","actions","baseInfo","bonding","getBondingState"],"mappings":"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","sourcesContent":["import { ethers, BigNumber, BigNumberish } from \"ethers\";\nimport { contractForRedeemHelper } from \"../helpers\";\nimport { getBalances, calculateUserBondDetails } from \"./AccountSlice\";\nimport { findOrLoadMarketPrice } from \"./AppSlice\";\nimport { error, info } from \"./MessagesSlice\";\nimport { clearPendingTxn, fetchPendingTxns } from \"./PendingTxnsSlice\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { getBondCalculator } from \"src/helpers/BondCalculator\";\nimport { RootState } from \"src/store\";\nimport {\n  IApproveBondAsyncThunk,\n  IBondAssetAsyncThunk,\n  ICalcBondDetailsAsyncThunk,\n  IJsonRPCError,\n  IRedeemAllBondsAsyncThunk,\n  IRedeemBondAsyncThunk,\n} from \"./interfaces\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\n\nexport const changeApproval = createAsyncThunk(\n  \"bonding/changeApproval\",\n  async ({ address, bond, provider, networkID }: IApproveBondAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const reserveContract = bond.getContractForReserve(networkID, signer);\n    const bondAddr = bond.getAddressForBond(networkID);\n\n    let approveTx;\n    let bondAllowance = await reserveContract.allowance(address, bondAddr);\n\n    // return early if approval already exists\n    if (bondAllowance.gt(BigNumber.from(\"0\"))) {\n      dispatch(info(\"Approval completed.\"));\n      dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n      return;\n    }\n\n    try {\n      approveTx = await reserveContract.approve(bondAddr, ethers.utils.parseUnits(\"1000000000\", \"ether\").toString());\n      dispatch(\n        fetchPendingTxns({\n          txnHash: approveTx.hash,\n          text: \"Approving \" + bond.displayName,\n          type: \"approve_\" + bond.name,\n        }),\n      );\n      await approveTx.wait();\n    } catch (e: unknown) {\n      dispatch(error((e as IJsonRPCError).message));\n    } finally {\n      if (approveTx) {\n        dispatch(clearPendingTxn(approveTx.hash));\n        dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n      }\n    }\n  },\n);\n\nexport interface IBondDetails {\n  bond: string;\n  bondDiscount: number;\n  debtRatio: number;\n  bondQuote: number;\n  purchased: number;\n  vestingTerm: number;\n  maxBondPrice: number;\n  bondPrice: number;\n  marketPrice: number;\n}\nexport const calcBondDetails = createAsyncThunk(\n  \"bonding/calcBondDetails\",\n  async ({ bond, value, provider, networkID }: ICalcBondDetailsAsyncThunk, { dispatch }): Promise<IBondDetails> => {\n    if (!value) {\n      value = \"0\";\n    }\n    const amountInWei = ethers.utils.parseEther(value);\n\n    // const vestingTerm = VESTING_TERM; // hardcoded for now\n    let bondPrice = BigNumber.from(0),\n      bondDiscount = 0,\n      valuation = 0,\n      bondQuote: BigNumberish = BigNumber.from(0);\n    const bondContract = bond.getContractForBond(networkID, provider);\n    const bondCalcContract = getBondCalculator(networkID, provider);\n\n    const terms = await bondContract.terms();\n    const maxBondPrice = await bondContract.maxPayout();\n    let debtRatio: BigNumberish = await bondContract.standardizedDebtRatio();\n    debtRatio = Number(debtRatio.toString()) / Math.pow(10, 9);\n\n    let marketPrice: number = 0;\n    try {\n      const originalPromiseResult = await dispatch(\n        findOrLoadMarketPrice({ networkID: networkID, provider: provider }),\n      ).unwrap();\n      marketPrice = originalPromiseResult?.marketPrice;\n    } catch (rejectedValueOrSerializedError) {\n      // handle error here\n      console.error(\"Returned a null response from dispatch(loadMarketPrice)\");\n    }\n\n    try {\n      bondPrice = await bondContract.bondPriceInUSD();\n      // bondDiscount = (marketPrice * Math.pow(10, 9) - bondPrice) / bondPrice; // 1 - bondPrice / (bondPrice * Math.pow(10, 9));\n      bondDiscount = (marketPrice * Math.pow(10, 18) - Number(bondPrice.toString())) / Number(bondPrice.toString()); // 1 - bondPrice / (bondPrice * Math.pow(10, 9));\n    } catch (e) {\n      console.log(\"error getting bondPriceInUSD\", e);\n    }\n\n    if (Number(value) === 0) {\n      // if inputValue is 0 avoid the bondQuote calls\n      bondQuote = BigNumber.from(0);\n    } else if (bond.isLP) {\n      valuation = Number(\n        (await bondCalcContract.valuation(bond.getAddressForReserve(networkID), amountInWei)).toString(),\n      );\n      bondQuote = await bondContract.payoutFor(valuation);\n      if (!amountInWei.isZero() && Number(bondQuote.toString()) < 100000) {\n        bondQuote = BigNumber.from(0);\n        const errorString = \"Amount is too small!\";\n        dispatch(error(errorString));\n      } else {\n        bondQuote = Number(bondQuote.toString()) / Math.pow(10, 9);\n      }\n    } else {\n      // RFV = DAI\n      bondQuote = await bondContract.payoutFor(amountInWei);\n\n      if (!amountInWei.isZero() && Number(bondQuote.toString()) < 100000000000000) {\n        bondQuote = BigNumber.from(0);\n        const errorString = \"Amount is too small!\";\n        dispatch(error(errorString));\n      } else {\n        bondQuote = Number(bondQuote.toString()) / Math.pow(10, 18);\n      }\n    }\n\n    // Display error if user tries to exceed maximum.\n    if (!!value && parseFloat(bondQuote.toString()) > Number(maxBondPrice.toString()) / Math.pow(10, 9)) {\n      const errorString =\n        \"You're trying to bond more than the maximum payout available! The maximum bond payout is \" +\n        (Number(maxBondPrice.toString()) / Math.pow(10, 9)).toFixed(2).toString() +\n        \" OHM.\";\n      dispatch(error(errorString));\n    }\n\n    // Calculate bonds purchased\n    let purchased = await bond.getTreasuryBalance(networkID, provider);\n\n    return {\n      bond: bond.name,\n      bondDiscount,\n      debtRatio: Number(debtRatio.toString()),\n      bondQuote: Number(bondQuote.toString()),\n      purchased,\n      vestingTerm: Number(terms.vestingTerm.toString()),\n      maxBondPrice: Number(maxBondPrice.toString()) / Math.pow(10, 9),\n      bondPrice: Number(bondPrice.toString()) / Math.pow(10, 18),\n      marketPrice: marketPrice,\n    };\n  },\n);\n\nexport const bondAsset = createAsyncThunk(\n  \"bonding/bondAsset\",\n  async ({ value, address, bond, networkID, provider, slippage }: IBondAssetAsyncThunk, { dispatch }) => {\n    const depositorAddress = address;\n    const acceptedSlippage = slippage / 100 || 0.005; // 0.5% as default\n    // parseUnits takes String => BigNumber\n    console.log(\"value\", value);\n    const valueInWei = ethers.utils.parseUnits(value.toString(), \"ether\");\n    console.log(\"amount\", valueInWei.toString());\n    let balance;\n    // Calculate maxPremium based on premium and slippage.\n    // const calculatePremium = await bonding.calculatePremium();\n    const signer = provider.getSigner();\n    const bondContract = bond.getContractForBond(networkID, signer);\n    const calculatePremium = await bondContract.bondPrice();\n    const maxPremium = Math.round(Number(calculatePremium.toString()) * (1 + acceptedSlippage));\n    console.log(\"maxPremium\", maxPremium);\n    console.log(\"depositorAddress\", depositorAddress);\n\n    // Deposit the bond\n    let bondTx;\n    let uaData = {\n      address: address,\n      value: value,\n      type: \"Bond\",\n      bondName: bond.displayName,\n      approved: true,\n      txHash: \"\",\n    };\n    try {\n      bondTx = await bondContract.deposit(valueInWei, maxPremium, depositorAddress);\n      dispatch(\n        fetchPendingTxns({ txnHash: bondTx.hash, text: \"Bonding \" + bond.displayName, type: \"bond_\" + bond.name }),\n      );\n      uaData.txHash = bondTx.hash;\n      await bondTx.wait();\n      // TODO: it may make more sense to only have it in the finally.\n      // UX preference (show pending after txn complete or after balance updated)\n\n      dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n    } catch (e: unknown) {\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\"You may be trying to bond more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"),\n        );\n      } else dispatch(error(rpcError.message));\n    } finally {\n      if (bondTx) {\n        segmentUA(uaData);\n        dispatch(clearPendingTxn(bondTx.hash));\n      }\n    }\n  },\n);\n\nexport const redeemBond = createAsyncThunk(\n  \"bonding/redeemBond\",\n  async ({ address, bond, networkID, provider, autostake }: IRedeemBondAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const bondContract = bond.getContractForBond(networkID, signer);\n\n    let redeemTx;\n    let uaData = {\n      address: address,\n      type: \"Redeem\",\n      bondName: bond.displayName,\n      autoStake: autostake,\n      approved: true,\n      txHash: \"\",\n    };\n    try {\n      redeemTx = await bondContract.redeem(address, autostake === true);\n      const pendingTxnType = \"redeem_bond_\" + bond + (autostake === true ? \"_autostake\" : \"\");\n      uaData.txHash = redeemTx.hash;\n      dispatch(\n        fetchPendingTxns({ txnHash: redeemTx.hash, text: \"Redeeming \" + bond.displayName, type: pendingTxnType }),\n      );\n\n      await redeemTx.wait();\n      await dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n\n      dispatch(getBalances({ address, networkID, provider }));\n    } catch (e: unknown) {\n      uaData.approved = false;\n      dispatch(error((e as IJsonRPCError).message));\n    } finally {\n      if (redeemTx) {\n        segmentUA(uaData);\n        dispatch(clearPendingTxn(redeemTx.hash));\n      }\n    }\n  },\n);\n\nexport const redeemAllBonds = createAsyncThunk(\n  \"bonding/redeemAllBonds\",\n  async ({ bonds, address, networkID, provider, autostake }: IRedeemAllBondsAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const redeemHelperContract = contractForRedeemHelper({ networkID, provider: signer });\n\n    let redeemAllTx;\n\n    try {\n      redeemAllTx = await redeemHelperContract.redeemAll(address, autostake);\n      const pendingTxnType = \"redeem_all_bonds\" + (autostake === true ? \"_autostake\" : \"\");\n\n      await dispatch(\n        fetchPendingTxns({ txnHash: redeemAllTx.hash, text: \"Redeeming All Bonds\", type: pendingTxnType }),\n      );\n\n      await redeemAllTx.wait();\n\n      bonds &&\n        bonds.forEach(async bond => {\n          dispatch(calculateUserBondDetails({ address, bond, networkID, provider }));\n        });\n\n      dispatch(getBalances({ address, networkID, provider }));\n    } catch (e: unknown) {\n      dispatch(error((e as IJsonRPCError).message));\n    } finally {\n      if (redeemAllTx) {\n        dispatch(clearPendingTxn(redeemAllTx.hash));\n      }\n    }\n  },\n);\n\n// Note(zx): this is a barebones interface for the state. Update to be more accurate\ninterface IBondSlice {\n  status: string;\n  [key: string]: any;\n}\n\nconst setBondState = (state: IBondSlice, payload: any) => {\n  const bond = payload.bond;\n  const newState = { ...state[bond], ...payload };\n  state[bond] = newState;\n  state.loading = false;\n};\n\nconst initialState: IBondSlice = {\n  status: \"idle\",\n};\n\nconst bondingSlice = createSlice({\n  name: \"bonding\",\n  initialState,\n  reducers: {\n    fetchBondSuccess(state, action) {\n      state[action.payload.bond] = action.payload;\n    },\n  },\n\n  extraReducers: builder => {\n    builder\n      .addCase(calcBondDetails.pending, state => {\n        state.loading = true;\n      })\n      .addCase(calcBondDetails.fulfilled, (state, action) => {\n        setBondState(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(calcBondDetails.rejected, (state, { error }) => {\n        state.loading = false;\n        console.error(error.message);\n      });\n  },\n});\n\nexport default bondingSlice.reducer;\n\nexport const { fetchBondSuccess } = bondingSlice.actions;\n\nconst baseInfo = (state: RootState) => state.bonding;\n\nexport const getBondingState = createSelector(baseInfo, bonding => bonding);\n"]},"metadata":{},"sourceType":"module"}