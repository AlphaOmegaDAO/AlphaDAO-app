{"ast":null,"code":"import { minutesAgo } from \"./index\";\nimport { EnvHelper } from \"./Environment\";\nimport { ethers } from \"ethers\";\n\n/**\n * NodeHelper used to parse which nodes are valid / invalid, working / not working\n * NodeHelper.currentRemovedNodes is Object representing invalidNodes\n * NodeHelper.logBadConnectionWithTimer logs connection stats for Nodes\n * NodeHelper.getNodesUris returns an array of valid node uris\n */\nexport class NodeHelper {\n  /**\n   * failedConnectionsMinuteLimit is the number of minutes that _maxFailedConnections must occur within\n   * for the node to be blocked.\n   */\n  // use sessionStorage so that we don't have to worry about resetting the invalidNodes list\n\n  /**\n   * remove the invalidNodes list entirely\n   * should be used as a failsafe IF we have invalidated ALL nodes AND we have no fallbacks\n   */\n  static _emptyInvalidNodesList() {\n    // if all nodes are removed && there are no fallbacks, then empty the list\n    if (EnvHelper.getFallbackURIs().length === 0 && Object.keys(NodeHelper.currentRemovedNodes).length === EnvHelper.getAPIUris().length) {\n      NodeHelper._storage.removeItem(NodeHelper._invalidNodesKey);\n    }\n  }\n\n  static _updateConnectionStatsForProvider(currentStats) {\n    const failedAt = new Date().getTime();\n    const failedConnectionCount = currentStats.failedConnectionCount || 0;\n\n    if (failedConnectionCount > 0 && currentStats.lastFailedConnectionAt > minutesAgo(NodeHelper._failedConnectionsMinutesLimit)) {\n      // more than 0 failed connections in the last (15) minutes\n      currentStats = {\n        lastFailedConnectionAt: failedAt,\n        failedConnectionCount: failedConnectionCount + 1\n      };\n    } else {\n      currentStats = {\n        lastFailedConnectionAt: failedAt,\n        failedConnectionCount: 1\n      };\n    }\n\n    return currentStats;\n  }\n\n  static _removeNodeFromProviders(providerKey, providerUrl) {\n    // get Object of current removed Nodes\n    // key = providerUrl, value = removedAt Timestamp\n    let currentRemovedNodesObj = NodeHelper.currentRemovedNodes;\n\n    if (Object.keys(currentRemovedNodesObj).includes(providerUrl)) {// already on the removed nodes list\n    } else {\n      // add to list\n      currentRemovedNodesObj[providerUrl] = new Date().getTime();\n\n      NodeHelper._storage.setItem(NodeHelper._invalidNodesKey, JSON.stringify(currentRemovedNodesObj)); // remove connection stats for this Node\n\n\n      NodeHelper._storage.removeItem(providerKey);\n    } // will only empty if no Fallbacks are provided\n\n\n    NodeHelper._emptyInvalidNodesList();\n  }\n  /**\n   * adds a bad connection stat to NodeHelper._storage for a given node\n   * if greater than `_maxFailedConnections` previous failures in last `_failedConnectionsMinuteLimit` minutes will remove node from list\n   * @param provider an Ethers provider\n   */\n\n\n  static logBadConnectionWithTimer(providerUrl) {\n    const providerKey = \"-nodeHelper:\" + providerUrl;\n    let currentConnectionStats = JSON.parse(NodeHelper._storage.getItem(providerKey) || \"{}\");\n    currentConnectionStats = NodeHelper._updateConnectionStatsForProvider(currentConnectionStats);\n\n    if (currentConnectionStats.failedConnectionCount >= NodeHelper._maxFailedConnections) {\n      // then remove this node from our provider list for 24 hours\n      NodeHelper._removeNodeFromProviders(providerKey, providerUrl);\n    } else {\n      NodeHelper._storage.setItem(providerKey, JSON.stringify(currentConnectionStats));\n    }\n  }\n  /**\n   * returns Array of APIURIs where NOT on invalidNodes list\n   */\n\n\n}\nNodeHelper._invalidNodesKey = \"invalidNodes\";\nNodeHelper._maxFailedConnections = 1;\nNodeHelper._failedConnectionsMinutesLimit = 15;\nNodeHelper._storage = window.sessionStorage;\nNodeHelper.currentRemovedNodes = JSON.parse(NodeHelper._storage.getItem(NodeHelper._invalidNodesKey) || \"{}\");\nNodeHelper.currentRemovedNodesURIs = Object.keys(NodeHelper.currentRemovedNodes);\n\nNodeHelper.getNodesUris = () => {\n  let allURIs = EnvHelper.getAPIUris();\n  let invalidNodes = NodeHelper.currentRemovedNodesURIs; // filter invalidNodes out of allURIs\n  // this allows duplicates in allURIs, removes both if invalid, & allows both if valid\n\n  allURIs = allURIs.filter(item => !invalidNodes.includes(item)); // return the remaining elements\n\n  if (allURIs.length === 0) {\n    // the invalidNodes list will be emptied when the user starts a new session\n    // In the meantime use the fallbacks\n    allURIs = EnvHelper.getFallbackURIs();\n  }\n\n  return allURIs;\n};\n\nNodeHelper.retryOnInvalid = () => {\n  const storageKey = \"-nodeHelper:retry\";\n\n  if (!NodeHelper._storage.getItem(storageKey)) {\n    NodeHelper._storage.setItem(storageKey, \"true\"); // if we haven't previously retried then return true\n\n\n    return true;\n  }\n\n  return false;\n};\n\nNodeHelper.checkAllNodesStatus = async () => {\n  return await Promise.all(NodeHelper.getNodesUris().map(async URI => {\n    let workingUrl = await NodeHelper.checkNodeStatus(URI);\n    return workingUrl;\n  }));\n};\n\nNodeHelper.checkNodeStatus = async url => {\n  // 1. confirm peerCount > 0 (as a HexValue)\n  let liveURL;\n  liveURL = await NodeHelper.queryNodeStatus({\n    url: url,\n    body: JSON.stringify({\n      method: \"net_peerCount\",\n      params: [],\n      id: 74,\n      jsonrpc: \"2.0\"\n    }),\n    nodeMethod: \"net_peerCount\"\n  }); // 2. confirm eth_syncing === false\n\n  if (liveURL) {\n    liveURL = await NodeHelper.queryNodeStatus({\n      url: url,\n      body: JSON.stringify({\n        method: \"eth_syncing\",\n        params: [],\n        id: 67,\n        jsonrpc: \"2.0\"\n      }),\n      nodeMethod: \"eth_syncing\"\n    });\n  }\n\n  return liveURL;\n};\n\nNodeHelper.queryNodeStatus = async ({\n  url,\n  body,\n  nodeMethod\n}) => {\n  let liveURL;\n\n  try {\n    let resp = await fetch(url, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: body\n    });\n\n    if (!resp.ok) {\n      throw Error(\"failed node connection\");\n    } else {\n      // response came back but is it healthy?\n      let jsonResponse = await resp.json();\n\n      if (NodeHelper.validityCheck({\n        nodeMethod,\n        resultVal: jsonResponse.result\n      })) {\n        liveURL = url;\n      } else {\n        throw Error(\"no suitable peers\");\n      }\n    }\n  } catch {\n    // some other type of issue\n    NodeHelper.logBadConnectionWithTimer(url);\n    liveURL = false;\n  }\n\n  return liveURL;\n};\n\nNodeHelper.validityCheck = ({\n  nodeMethod,\n  resultVal\n}) => {\n  switch (nodeMethod) {\n    case \"net_peerCount\":\n      if (resultVal === ethers.utils.hexValue(0)) {\n        return false;\n      } else {\n        return true;\n      }\n\n      break;\n\n    case \"eth_syncing\":\n      return resultVal === false;\n      break;\n\n    default:\n      return false;\n  }\n};","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/helpers/NodeHelper.ts"],"names":["minutesAgo","EnvHelper","ethers","NodeHelper","_emptyInvalidNodesList","getFallbackURIs","length","Object","keys","currentRemovedNodes","getAPIUris","_storage","removeItem","_invalidNodesKey","_updateConnectionStatsForProvider","currentStats","failedAt","Date","getTime","failedConnectionCount","lastFailedConnectionAt","_failedConnectionsMinutesLimit","_removeNodeFromProviders","providerKey","providerUrl","currentRemovedNodesObj","includes","setItem","JSON","stringify","logBadConnectionWithTimer","currentConnectionStats","parse","getItem","_maxFailedConnections","window","sessionStorage","currentRemovedNodesURIs","getNodesUris","allURIs","invalidNodes","filter","item","retryOnInvalid","storageKey","checkAllNodesStatus","Promise","all","map","URI","workingUrl","checkNodeStatus","url","liveURL","queryNodeStatus","body","method","params","id","jsonrpc","nodeMethod","resp","fetch","mode","headers","ok","Error","jsonResponse","json","validityCheck","resultVal","result","utils","hexValue"],"mappings":"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","sourcesContent":["import { minutesAgo } from \"./index\";\nimport { EnvHelper } from \"./Environment\";\nimport { ethers } from \"ethers\";\n\ninterface ICurrentStats {\n  failedConnectionCount: number;\n  lastFailedConnectionAt: number;\n}\n\n/**\n * NodeHelper used to parse which nodes are valid / invalid, working / not working\n * NodeHelper.currentRemovedNodes is Object representing invalidNodes\n * NodeHelper.logBadConnectionWithTimer logs connection stats for Nodes\n * NodeHelper.getNodesUris returns an array of valid node uris\n */\nexport class NodeHelper {\n  static _invalidNodesKey = \"invalidNodes\";\n  static _maxFailedConnections = 1;\n  /**\n   * failedConnectionsMinuteLimit is the number of minutes that _maxFailedConnections must occur within\n   * for the node to be blocked.\n   */\n  static _failedConnectionsMinutesLimit = 15;\n\n  // use sessionStorage so that we don't have to worry about resetting the invalidNodes list\n  static _storage = window.sessionStorage;\n\n  static currentRemovedNodes = JSON.parse(NodeHelper._storage.getItem(NodeHelper._invalidNodesKey) || \"{}\");\n  static currentRemovedNodesURIs = Object.keys(NodeHelper.currentRemovedNodes);\n\n  /**\n   * remove the invalidNodes list entirely\n   * should be used as a failsafe IF we have invalidated ALL nodes AND we have no fallbacks\n   */\n  static _emptyInvalidNodesList() {\n    // if all nodes are removed && there are no fallbacks, then empty the list\n    if (\n      EnvHelper.getFallbackURIs().length === 0 &&\n      Object.keys(NodeHelper.currentRemovedNodes).length === EnvHelper.getAPIUris().length\n    ) {\n      NodeHelper._storage.removeItem(NodeHelper._invalidNodesKey);\n    }\n  }\n\n  static _updateConnectionStatsForProvider(currentStats: ICurrentStats) {\n    const failedAt = new Date().getTime();\n    const failedConnectionCount = currentStats.failedConnectionCount || 0;\n    if (\n      failedConnectionCount > 0 &&\n      currentStats.lastFailedConnectionAt > minutesAgo(NodeHelper._failedConnectionsMinutesLimit)\n    ) {\n      // more than 0 failed connections in the last (15) minutes\n      currentStats = {\n        lastFailedConnectionAt: failedAt,\n        failedConnectionCount: failedConnectionCount + 1,\n      };\n    } else {\n      currentStats = {\n        lastFailedConnectionAt: failedAt,\n        failedConnectionCount: 1,\n      };\n    }\n    return currentStats;\n  }\n\n  static _removeNodeFromProviders(providerKey: string, providerUrl: string) {\n    // get Object of current removed Nodes\n    // key = providerUrl, value = removedAt Timestamp\n    let currentRemovedNodesObj = NodeHelper.currentRemovedNodes;\n    if (Object.keys(currentRemovedNodesObj).includes(providerUrl)) {\n      // already on the removed nodes list\n    } else {\n      // add to list\n      currentRemovedNodesObj[providerUrl] = new Date().getTime();\n      NodeHelper._storage.setItem(NodeHelper._invalidNodesKey, JSON.stringify(currentRemovedNodesObj));\n      // remove connection stats for this Node\n      NodeHelper._storage.removeItem(providerKey);\n    }\n\n    // will only empty if no Fallbacks are provided\n    NodeHelper._emptyInvalidNodesList();\n  }\n\n  /**\n   * adds a bad connection stat to NodeHelper._storage for a given node\n   * if greater than `_maxFailedConnections` previous failures in last `_failedConnectionsMinuteLimit` minutes will remove node from list\n   * @param provider an Ethers provider\n   */\n  static logBadConnectionWithTimer(providerUrl: string) {\n    const providerKey: string = \"-nodeHelper:\" + providerUrl;\n\n    let currentConnectionStats = JSON.parse(NodeHelper._storage.getItem(providerKey) || \"{}\");\n    currentConnectionStats = NodeHelper._updateConnectionStatsForProvider(currentConnectionStats);\n    if (currentConnectionStats.failedConnectionCount >= NodeHelper._maxFailedConnections) {\n      // then remove this node from our provider list for 24 hours\n      NodeHelper._removeNodeFromProviders(providerKey, providerUrl);\n    } else {\n      NodeHelper._storage.setItem(providerKey, JSON.stringify(currentConnectionStats));\n    }\n  }\n\n  /**\n   * returns Array of APIURIs where NOT on invalidNodes list\n   */\n  static getNodesUris = () => {\n    let allURIs = EnvHelper.getAPIUris();\n    let invalidNodes = NodeHelper.currentRemovedNodesURIs;\n    // filter invalidNodes out of allURIs\n    // this allows duplicates in allURIs, removes both if invalid, & allows both if valid\n    allURIs = allURIs.filter(item => !invalidNodes.includes(item));\n\n    // return the remaining elements\n    if (allURIs.length === 0) {\n      // the invalidNodes list will be emptied when the user starts a new session\n      // In the meantime use the fallbacks\n      allURIs = EnvHelper.getFallbackURIs();\n    }\n    return allURIs;\n  };\n\n  /**\n   * stores a retry check to be used to prevent constant Node Health retries\n   * returns true if we haven't previously retried, else false\n   * @returns boolean\n   */\n  static retryOnInvalid = () => {\n    const storageKey = \"-nodeHelper:retry\";\n    if (!NodeHelper._storage.getItem(storageKey)) {\n      NodeHelper._storage.setItem(storageKey, \"true\");\n      // if we haven't previously retried then return true\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * iterate through all the nodes we have with a chainId check.\n   * - log the failing nodes\n   * - _maxFailedConnections fails in < _failedConnectionsMinutesLimit sends the node to the invalidNodes list\n   * returns an Array of working mainnet nodes\n   */\n  static checkAllNodesStatus = async () => {\n    return await Promise.all(\n      NodeHelper.getNodesUris().map(async URI => {\n        let workingUrl = await NodeHelper.checkNodeStatus(URI);\n        return workingUrl;\n      }),\n    );\n  };\n\n  /**\n   * 403 errors are not caught by fetch so we check response.status, too\n   * this func returns a workingURL string or false;\n   */\n  static checkNodeStatus = async (url: string) => {\n    // 1. confirm peerCount > 0 (as a HexValue)\n    let liveURL;\n    liveURL = await NodeHelper.queryNodeStatus({\n      url: url,\n      body: JSON.stringify({ method: \"net_peerCount\", params: [], id: 74, jsonrpc: \"2.0\" }),\n      nodeMethod: \"net_peerCount\",\n    });\n    // 2. confirm eth_syncing === false\n    if (liveURL) {\n      liveURL = await NodeHelper.queryNodeStatus({\n        url: url,\n        body: JSON.stringify({ method: \"eth_syncing\", params: [], id: 67, jsonrpc: \"2.0\" }),\n        nodeMethod: \"eth_syncing\",\n      });\n    }\n    return liveURL;\n  };\n\n  static queryNodeStatus = async ({ url, body, nodeMethod }: { url: string; body: string; nodeMethod: string }) => {\n    let liveURL: boolean | string;\n    try {\n      let resp = await fetch(url, {\n        method: \"POST\",\n        mode: \"cors\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: body,\n      });\n      if (!resp.ok) {\n        throw Error(\"failed node connection\");\n      } else {\n        // response came back but is it healthy?\n        let jsonResponse = await resp.json();\n        if (NodeHelper.validityCheck({ nodeMethod, resultVal: jsonResponse.result })) {\n          liveURL = url;\n        } else {\n          throw Error(\"no suitable peers\");\n        }\n      }\n    } catch {\n      // some other type of issue\n      NodeHelper.logBadConnectionWithTimer(url);\n      liveURL = false;\n    }\n    return liveURL;\n  };\n\n  /**\n   * handles different validityCheck for different node health endpoints\n   * * `net_peerCount` should be > 0 (0x0 as a Hex Value). If it is === 0 then queries will timeout within ethers.js\n   * * `net_peerCount` === 0 whenever the node has recently restarted.\n   * * `eth_syncing` should be false. If not false then queries will fail within ethers.js\n   * * `eth_syncing` is not false whenever the node is connected to a peer that is still syncing.\n   * @param nodeMethod \"net_peerCount\" || \"eth_syncing\"\n   * @param resultVal the result object from the nodeMethod json query\n   * @returns true if valid node, false if invalid\n   */\n  static validityCheck = ({ nodeMethod, resultVal }: { nodeMethod: string; resultVal: string | boolean }) => {\n    switch (nodeMethod) {\n      case \"net_peerCount\":\n        if (resultVal === ethers.utils.hexValue(0)) {\n          return false;\n        } else {\n          return true;\n        }\n        break;\n      case \"eth_syncing\":\n        return resultVal === false;\n        break;\n      default:\n        return false;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}