{"ast":null,"code":"import { ethers, BigNumber } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20ABI } from \"../abi/IERC20.json\";\nimport { abi as wsOHM } from \"../abi/wsOHM.json\";\nimport { clearPendingTxn, fetchPendingTxns, getWrappingTypeText } from \"./PendingTxnsSlice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./AccountSlice\";\nimport { error, info } from \"../slices/MessagesSlice\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\n\nfunction alreadyApprovedToken(token, wrapAllowance, unwrapAllowance) {\n  // set defaults\n  let bigZero = BigNumber.from(\"0\");\n  let applicableAllowance = bigZero; // determine which allowance to check\n\n  if (token === \"sohm\") {\n    applicableAllowance = wrapAllowance;\n  } else if (token === \"wsohm\") {\n    applicableAllowance = unwrapAllowance;\n  } // check if allowance exists\n\n\n  if (applicableAllowance.gt(bigZero)) return true;\n  return false;\n}\n\nexport const changeApproval = createAsyncThunk(\"wrap/changeApproval\", async ({\n  token,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const sohmContract = new ethers.Contract(addresses[networkID].SOHM_ADDRESS, ierc20ABI, signer);\n  const wsohmContract = new ethers.Contract(addresses[networkID].WSOHM_ADDRESS, ierc20ABI, signer);\n  let approveTx;\n  let wrapAllowance = await sohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n  let unwrapAllowance = await wsohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS); // return early if approval has already happened\n\n  if (alreadyApprovedToken(token, wrapAllowance, unwrapAllowance)) {\n    dispatch(info(\"Approval completed.\"));\n    return dispatch(fetchAccountSuccess({\n      wrapping: {\n        ohmWrap: +wrapAllowance,\n        ohmUnwrap: +unwrapAllowance\n      }\n    }));\n  }\n\n  try {\n    if (token === \"sohm\") {\n      // won't run if wrapAllowance > 0\n      approveTx = await sohmContract.approve(addresses[networkID].WSOHM_ADDRESS, ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString());\n    } else if (token === \"wsohm\") {\n      approveTx = await wsohmContract.approve(addresses[networkID].WSOHM_ADDRESS, ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString());\n    }\n\n    const text = \"Approve \" + (token === \"sohm\" ? \"Wrapping\" : \"Unwrapping\");\n    const pendingTxnType = token === \"sohm\" ? \"approve_wrapping\" : \"approve_unwrapping\";\n\n    if (approveTx) {\n      dispatch(fetchPendingTxns({\n        txnHash: approveTx.hash,\n        text,\n        type: pendingTxnType\n      }));\n      await approveTx.wait();\n    }\n  } catch (e) {\n    dispatch(error(e.message));\n    return;\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  } // go get fresh allowances\n\n\n  wrapAllowance = await sohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n  unwrapAllowance = await wsohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n  return dispatch(fetchAccountSuccess({\n    wrapping: {\n      ohmWrap: +wrapAllowance,\n      ohmUnwrap: +unwrapAllowance\n    }\n  }));\n});\nexport const changeWrap = createAsyncThunk(\"wrap/changeWrap\", async ({\n  action,\n  value,\n  provider,\n  address,\n  networkID\n}, {\n  dispatch\n}) => {\n  if (!provider) {\n    dispatch(error(\"Please connect your wallet!\"));\n    return;\n  }\n\n  const signer = provider.getSigner();\n  const wsohmContract = new ethers.Contract(addresses[networkID].WSOHM_ADDRESS, wsOHM, signer);\n  let wrapTx;\n  let uaData = {\n    address: address,\n    value: value,\n    approved: true,\n    txHash: null,\n    type: null\n  };\n\n  try {\n    if (action === \"wrap\") {\n      uaData.type = \"wrap\";\n      wrapTx = await wsohmContract.wrap(ethers.utils.parseUnits(value, \"gwei\"));\n    } else {\n      uaData.type = \"unwrap\";\n      wrapTx = await wsohmContract.unwrap(ethers.utils.parseUnits(value));\n    }\n\n    const pendingTxnType = action === \"wrap\" ? \"wrapping\" : \"unwrapping\";\n    uaData.txHash = wrapTx.hash;\n    dispatch(fetchPendingTxns({\n      txnHash: wrapTx.hash,\n      text: getWrappingTypeText(action),\n      type: pendingTxnType\n    }));\n    await wrapTx.wait();\n  } catch (e) {\n    uaData.approved = false;\n    const rpcError = e;\n\n    if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n      dispatch(error(\"You may be trying to wrap more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"));\n    } else {\n      dispatch(error(rpcError.message));\n    }\n\n    return;\n  } finally {\n    if (wrapTx) {\n      segmentUA(uaData);\n      dispatch(clearPendingTxn(wrapTx.hash));\n    }\n  }\n\n  dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n});","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/WrapThunk.ts"],"names":["ethers","BigNumber","addresses","abi","ierc20ABI","wsOHM","clearPendingTxn","fetchPendingTxns","getWrappingTypeText","createAsyncThunk","fetchAccountSuccess","getBalances","error","info","segmentUA","alreadyApprovedToken","token","wrapAllowance","unwrapAllowance","bigZero","from","applicableAllowance","gt","changeApproval","provider","address","networkID","dispatch","signer","getSigner","sohmContract","Contract","SOHM_ADDRESS","wsohmContract","WSOHM_ADDRESS","approveTx","allowance","wrapping","ohmWrap","ohmUnwrap","approve","utils","parseUnits","toString","text","pendingTxnType","txnHash","hash","type","wait","e","message","changeWrap","action","value","wrapTx","uaData","approved","txHash","wrap","unwrap","rpcError","code","indexOf"],"mappings":"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","sourcesContent":["import { ethers, BigNumber } from \"ethers\";\nimport { addresses } from \"../constants\";\nimport { abi as ierc20ABI } from \"../abi/IERC20.json\";\nimport { abi as wsOHM } from \"../abi/wsOHM.json\";\nimport { clearPendingTxn, fetchPendingTxns, getWrappingTypeText } from \"./PendingTxnsSlice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./AccountSlice\";\nimport { error, info } from \"../slices/MessagesSlice\";\nimport { IActionValueAsyncThunk, IChangeApprovalAsyncThunk, IJsonRPCError } from \"./interfaces\";\nimport { segmentUA } from \"../helpers/userAnalyticHelpers\";\nimport { IERC20, WsOHM } from \"src/typechain\";\n\ninterface IUAData {\n  address: string;\n  value: string;\n  approved: boolean;\n  txHash: string | null;\n  type: string | null;\n}\n\nfunction alreadyApprovedToken(token: string, wrapAllowance: BigNumber, unwrapAllowance: BigNumber) {\n  // set defaults\n  let bigZero = BigNumber.from(\"0\");\n  let applicableAllowance = bigZero;\n\n  // determine which allowance to check\n  if (token === \"sohm\") {\n    applicableAllowance = wrapAllowance;\n  } else if (token === \"wsohm\") {\n    applicableAllowance = unwrapAllowance;\n  }\n\n  // check if allowance exists\n  if (applicableAllowance.gt(bigZero)) return true;\n\n  return false;\n}\n\nexport const changeApproval = createAsyncThunk(\n  \"wrap/changeApproval\",\n  async ({ token, provider, address, networkID }: IChangeApprovalAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const sohmContract = new ethers.Contract(addresses[networkID].SOHM_ADDRESS as string, ierc20ABI, signer) as IERC20;\n    const wsohmContract = new ethers.Contract(\n      addresses[networkID].WSOHM_ADDRESS as string,\n      ierc20ABI,\n      signer,\n    ) as IERC20;\n    let approveTx;\n    let wrapAllowance = await sohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n    let unwrapAllowance = await wsohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n\n    // return early if approval has already happened\n    if (alreadyApprovedToken(token, wrapAllowance, unwrapAllowance)) {\n      dispatch(info(\"Approval completed.\"));\n      return dispatch(\n        fetchAccountSuccess({\n          wrapping: {\n            ohmWrap: +wrapAllowance,\n            ohmUnwrap: +unwrapAllowance,\n          },\n        }),\n      );\n    }\n\n    try {\n      if (token === \"sohm\") {\n        // won't run if wrapAllowance > 0\n        approveTx = await sohmContract.approve(\n          addresses[networkID].WSOHM_ADDRESS,\n          ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString(),\n        );\n      } else if (token === \"wsohm\") {\n        approveTx = await wsohmContract.approve(\n          addresses[networkID].WSOHM_ADDRESS,\n          ethers.utils.parseUnits(\"1000000000\", \"gwei\").toString(),\n        );\n      }\n\n      const text = \"Approve \" + (token === \"sohm\" ? \"Wrapping\" : \"Unwrapping\");\n      const pendingTxnType = token === \"sohm\" ? \"approve_wrapping\" : \"approve_unwrapping\";\n      if (approveTx) {\n        dispatch(fetchPendingTxns({ txnHash: approveTx.hash, text, type: pendingTxnType }));\n\n        await approveTx.wait();\n      }\n    } catch (e: unknown) {\n      dispatch(error((e as IJsonRPCError).message));\n      return;\n    } finally {\n      if (approveTx) {\n        dispatch(clearPendingTxn(approveTx.hash));\n      }\n    }\n\n    // go get fresh allowances\n    wrapAllowance = await sohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n    unwrapAllowance = await wsohmContract.allowance(address, addresses[networkID].WSOHM_ADDRESS);\n\n    return dispatch(\n      fetchAccountSuccess({\n        wrapping: {\n          ohmWrap: +wrapAllowance,\n          ohmUnwrap: +unwrapAllowance,\n        },\n      }),\n    );\n  },\n);\n\nexport const changeWrap = createAsyncThunk(\n  \"wrap/changeWrap\",\n  async ({ action, value, provider, address, networkID }: IActionValueAsyncThunk, { dispatch }) => {\n    if (!provider) {\n      dispatch(error(\"Please connect your wallet!\"));\n      return;\n    }\n\n    const signer = provider.getSigner();\n    const wsohmContract = new ethers.Contract(addresses[networkID].WSOHM_ADDRESS as string, wsOHM, signer) as WsOHM;\n\n    let wrapTx;\n    let uaData: IUAData = {\n      address: address,\n      value: value,\n      approved: true,\n      txHash: null,\n      type: null,\n    };\n    try {\n      if (action === \"wrap\") {\n        uaData.type = \"wrap\";\n        wrapTx = await wsohmContract.wrap(ethers.utils.parseUnits(value, \"gwei\"));\n      } else {\n        uaData.type = \"unwrap\";\n        wrapTx = await wsohmContract.unwrap(ethers.utils.parseUnits(value));\n      }\n      const pendingTxnType = action === \"wrap\" ? \"wrapping\" : \"unwrapping\";\n      uaData.txHash = wrapTx.hash;\n      dispatch(fetchPendingTxns({ txnHash: wrapTx.hash, text: getWrappingTypeText(action), type: pendingTxnType }));\n      await wrapTx.wait();\n    } catch (e: unknown) {\n      uaData.approved = false;\n      const rpcError = e as IJsonRPCError;\n      if (rpcError.code === -32603 && rpcError.message.indexOf(\"ds-math-sub-underflow\") >= 0) {\n        dispatch(\n          error(\"You may be trying to wrap more than your balance! Error code: 32603. Message: ds-math-sub-underflow\"),\n        );\n      } else {\n        dispatch(error(rpcError.message));\n      }\n      return;\n    } finally {\n      if (wrapTx) {\n        segmentUA(uaData);\n\n        dispatch(clearPendingTxn(wrapTx.hash));\n      }\n    }\n    dispatch(getBalances({ address, networkID, provider }));\n  },\n);\n"]},"metadata":{},"sourceType":"module"}