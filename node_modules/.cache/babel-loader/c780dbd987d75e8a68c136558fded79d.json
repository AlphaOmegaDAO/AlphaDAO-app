{"ast":null,"code":"import { setAll } from \"../helpers\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nexport const getLusdData = createAsyncThunk(\"stake/getLusdData\", async ({\n  address,\n  networkID,\n  provider\n}) => {// // only works on mainnet\n  // if (networkID !== 1) {\n  //   // we don't have rinkeby contracts\n  //   return { apy: 0, tvl: 0 };\n  // } else {\n  //   // calcing APY & tvl\n  //   const crucibleDetes = await calcAludelDetes(networkID, provider);\n  //   let avgApy = crucibleDetes.averageApy;\n  //   if (isNaN(avgApy)) avgApy = 0;\n  //   return {\n  //     apy: avgApy,\n  //     tvl: crucibleDetes.tvlUsd,\n  //     // NOTE (appleseed): balance is in accountSlice for the bond\n  //     // balance: ethers.utils.formatUnits(sushiOhmLusdBalance, \"gwei\"),\n  //   };\n  // }\n});\n/**\n * interface for object returned from getLusdData + loading status\n */\n\nconst initialState = {\n  loading: false,\n  apy: 0,\n  tvl: 0\n};\nconst lusdSlice = createSlice({\n  name: \"lusdData\",\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(getLusdData.pending, state => {\n      state.loading = true;\n    }).addCase(getLusdData.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(getLusdData.rejected, (state, {\n      error\n    }) => {\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\nexport default lusdSlice.reducer;\n\nconst baseInfo = state => state.lusdData;\n\nexport const getLusdState = createSelector(baseInfo, app => app);","map":{"version":3,"sources":["C:/arete/AlphaDAO-react/src/slices/LusdSlice.ts"],"names":["setAll","createSlice","createSelector","createAsyncThunk","getLusdData","address","networkID","provider","initialState","loading","apy","tvl","lusdSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","rejected","error","console","log","reducer","baseInfo","lusdData","getLusdState","app"],"mappings":"AAAA,SAASA,MAAT,QAAuB,YAAvB;AACA,SAASC,WAAT,EAAsBC,cAAtB,EAAsCC,gBAAtC,QAA8D,kBAA9D;AAKA,OAAO,MAAMC,WAAW,GAAGD,gBAAgB,CACzC,mBADyC,EAEzC,OAAO;AAAEE,EAAAA,OAAF;AAAWC,EAAAA,SAAX;AAAsBC,EAAAA;AAAtB,CAAP,KAAoE,CAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD,CAnBwC,CAApC;AAsBP;AACA;AACA;;AAOA,MAAMC,YAA8B,GAAG;AACrCC,EAAAA,OAAO,EAAE,KAD4B;AAErCC,EAAAA,GAAG,EAAE,CAFgC;AAGrCC,EAAAA,GAAG,EAAE;AAHgC,CAAvC;AAMA,MAAMC,SAAS,GAAGX,WAAW,CAAC;AAC5BY,EAAAA,IAAI,EAAE,UADsB;AAE5BL,EAAAA,YAF4B;AAG5BM,EAAAA,QAAQ,EAAE,EAHkB;AAI5BC,EAAAA,aAAa,EAAEC,OAAO,IAAI;AACxBA,IAAAA,OAAO,CACJC,OADH,CACWb,WAAW,CAACc,OADvB,EACgCC,KAAK,IAAI;AACrCA,MAAAA,KAAK,CAACV,OAAN,GAAgB,IAAhB;AACD,KAHH,EAIGQ,OAJH,CAIWb,WAAW,CAACgB,SAJvB,EAIkC,CAACD,KAAD,EAAQE,MAAR,KAAmB;AACjDrB,MAAAA,MAAM,CAACmB,KAAD,EAAQE,MAAM,CAACC,OAAf,CAAN;AACAH,MAAAA,KAAK,CAACV,OAAN,GAAgB,KAAhB;AACD,KAPH,EAQGQ,OARH,CAQWb,WAAW,CAACmB,QARvB,EAQiC,CAACJ,KAAD,EAAQ;AAAEK,MAAAA;AAAF,KAAR,KAAsB;AACnDL,MAAAA,KAAK,CAACV,OAAN,GAAgB,KAAhB;AACAgB,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD,KAXH;AAYD;AAjB2B,CAAD,CAA7B;AAoBA,eAAeZ,SAAS,CAACe,OAAzB;;AAEA,MAAMC,QAAQ,GAAIT,KAAD,IAAgBA,KAAK,CAACU,QAAvC;;AAEA,OAAO,MAAMC,YAAY,GAAG5B,cAAc,CAAC0B,QAAD,EAAWG,GAAG,IAAIA,GAAlB,CAAnC","sourcesContent":["import { setAll } from \"../helpers\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { IBaseAddressAsyncThunk } from \"./interfaces\";\n\nimport { calcAludelDetes } from \"../helpers/OhmLusdCrucible\";\n\nexport const getLusdData = createAsyncThunk(\n  \"stake/getLusdData\",\n  async ({ address, networkID, provider }: IBaseAddressAsyncThunk) => {\n    // // only works on mainnet\n    // if (networkID !== 1) {\n    //   // we don't have rinkeby contracts\n    //   return { apy: 0, tvl: 0 };\n    // } else {\n    //   // calcing APY & tvl\n    //   const crucibleDetes = await calcAludelDetes(networkID, provider);\n    //   let avgApy = crucibleDetes.averageApy;\n    //   if (isNaN(avgApy)) avgApy = 0;\n    //   return {\n    //     apy: avgApy,\n    //     tvl: crucibleDetes.tvlUsd,\n    //     // NOTE (appleseed): balance is in accountSlice for the bond\n    //     // balance: ethers.utils.formatUnits(sushiOhmLusdBalance, \"gwei\"),\n    //   };\n    // }\n  },\n);\n\n/**\n * interface for object returned from getLusdData + loading status\n */\nexport interface IUserLusdDetails {\n  apy: number;\n  tvl: number;\n  loading: boolean;\n}\n\nconst initialState: IUserLusdDetails = {\n  loading: false,\n  apy: 0,\n  tvl: 0,\n};\n\nconst lusdSlice = createSlice({\n  name: \"lusdData\",\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder\n      .addCase(getLusdData.pending, state => {\n        state.loading = true;\n      })\n      .addCase(getLusdData.fulfilled, (state, action) => {\n        setAll(state, action.payload);\n        state.loading = false;\n      })\n      .addCase(getLusdData.rejected, (state, { error }) => {\n        state.loading = false;\n        console.log(error);\n      });\n  },\n});\n\nexport default lusdSlice.reducer;\n\nconst baseInfo = (state: any) => state.lusdData;\n\nexport const getLusdState = createSelector(baseInfo, app => app);\n"]},"metadata":{},"sourceType":"module"}